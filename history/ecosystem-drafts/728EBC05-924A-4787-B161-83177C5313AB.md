<!--
  SPDX-FileCopyrightText: 2026 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

Here is the unified **Ecosystem Strategy & Architecture** document. It synthesizes your "Jujube Redux" specification, the "Frame API" decision (Proposal 3), and the "Big Tent" strategy into a single source of truth.  
This document is designed for the Wiki. It serves as the project's constitution.

# ---

**The RatatuiRuby Constitution: Ecosystem Strategy & Architecture**

Version: 2.0 (The "Big Tent" Era)  
Status: Ratified  
Scope: Global

## ---

**Chapter 1: The "Big Tent" Vision**

### **What's in this Chapter**

* **The Mission:** Why we exist in a world with CharmRuby and Rust.  
* **The Forked Path Strategy:** Supporting both Functional (TEA) and Object-Oriented (OO) paradigms.  
* **The Ecosystem Topology:** Naming conventions, require paths, and gem hierarchy.  
* **The "No Dead Ends" Promise:** Ensuring users can start simple and grow complex without rewriting the engine.

### **Chapter Summary**

We are building the universal terminal runtime for Ruby. We do not force developers into a single architectural box. Instead, we provide a shared, high-performance Engine (Layer 1\) that supports two distinct, mutually exclusive application paths.  
**Path A (Functional)** uses *The Elm Architecture*. It is optimized for data-driven tools, CLI utilities, and developers who prefer immutable state. It prioritizes correctness and simplicity.  
**Path B (Object-Oriented)** uses *Stateful Components*. It is optimized for dashboards, enterprise platforms, and developers accustomed to Rails or React. It prioritizes encapsulation and composition.  
By supporting both paths on a single Rust-powered engine, we capture the entire market—from the script scripter to the platform architect—without splitting our engineering resources. We win on performance. We win on flexibility. We win on Ruby ergonomics.

## ---

**Chapter 2: Layer 1 — The Engine (ratatui\_ruby)**

### **What's in this Chapter**

* **The Prime Directive:** Remain stateless, unopinionated, and performant.  
* **The Frame API (Proposal 3):** Why we adopted explicit rendering control over declarative trees.  
* **The "Calculate Once" Pattern:** Solving layout thrashing by exposing layout results during the draw phase.  
* **Critical Primitives:** The "Missing 4" (Text Measurement, Cursor, Modifiers, Resize).  
* **Concurrency Primitives:** Non-blocking poll\_event implementation.

### **Chapter Summary**

The Engine is the bedrock. It wraps the Ratatui Rust crate but exposes it through an idiomatic Ruby interface. As of v1.0, the Engine has moved beyond simple declarative trees to a **Frame-Based API**.  
This change is architectural, not just syntactic. By yielding a Frame object to the draw block, we give upper layers explicit control over widget placement (frame.render(widget, area)). This aligns us 1:1 with Rust's native API, enabling direct knowledge transfer. Crucially, it allows Layer 1.5 (Components) to manage its own hit-testing logic without requiring the Engine to guess user intent.  
The Engine remains strictly immediate-mode. It draws what it is told, forgets it immediately, and waits for the next frame. It is the only layer allowed to touch FFI.

## ---

**Chapter 3: Layer 1.25 — The Functional Path (ratatui\_ruby-tea)**

### **What's in this Chapter**

* **Philosophy:** "Data In, Data Out." Rejection of inheritance in favor of composition.  
* **The Runtime:** A minimal loop managing Model, Update, and View.  
* **The "Just Ruby" Spec:** Using Procs (Commands) and Arrays (Batches) instead of rigid classes.  
* **The Trojan Horse:** Enforcing Ractor-safety (immutability) in v1.0 to guarantee v2.0 scalability.  
* **Batteries Included:** Standard library commands vs. the "Pro" ecosystem.

### **Chapter Summary**

Layer 1.25 is the runtime for Path A. It implements The Elm Architecture with a distinct "Ruby Twist." We reject the Java-like pattern of inheriting from base classes. Instead, the runtime accepts **Callable Objects** (Procs, Lambdas, or Service Objects). This promotes functional purity and ease of testing.  
We prioritize stability over magic. The runtime executes updates on the main thread to ensure 60 FPS rendering, while offloading Commands (side effects) to a worker pool. To prepare for Ruby 4.0's concurrency model, we enforce a "Trojan Horse" policy: the runtime validates that all Messages and Models are deeply frozen. Users write Ractor-safe code today, unknowingly preparing for a parallel future.  
This layer is not a toy. It is a robust, production-grade runtime for state machines, powered by the same Engine as our enterprise tools.

## ---

**Chapter 4: Layer 1.5 — The Component Path (ratatui\_ruby-components)**

### **What's in this Chapter**

* **Philosophy:** Encapsulation and Retained Mode state.  
* **The Bridge:** How Stateful Components generate Stateless Layer 1 structs.  
* **The Layout Cycle:** Using the Frame API for precise hit-testing and event routing.  
* **The Focus Manager:** Handling tab cycles and keyboard routing automatically.  
* **Interoperability:** Why Components cannot live inside a TEA application.

### **Chapter Summary**

Layer 1.5 is the toolkit for Path B. It introduces the concept of *objects that persist*. A Button in this layer is not just a hash of parameters; it is a living Ruby object that knows if it is hovered, focused, or disabled.  
This layer bridges the gap between the stateless Engine and the stateful Application. It uses the Engine's **Frame API** to render itself into specific screen coordinates. It then remembers those coordinates. When an input event arrives, the Component layer checks its registry, finds the component at (x, y), and routes the event directly to it.  
This is the layer that makes "Enterprise" apps possible. It enables developers to build reusable UI libraries, complex forms, and tabbed dashboards without manually managing a global event loop.

## ---

**Chapter 5: Layer 2 — The Syntax (glimmer-dsl-ratatui)**

### **What's in this Chapter**

* **The Goal:** Declarative, readable UI code without boilerplate.  
* **The Dual Adapter:** How the DSL wraps Layer 1.5 (Components) *and* Layer 1.25 (TEA Views).  
* **Data Binding:** The distinction between Unidirectional (TEA) and Bidirectional (Components) binding.  
* **The Syntax Tree:** Mapping Glimmer keywords to underlying objects.

### **Chapter Summary**

Glimmer is the syntax layer. It is not an architecture; it is a vocabulary. It allows developers to describe *what* they want, rather than *how* to build it.  
Crucially, this DSL supports both ecosystem paths.  
For Path A (TEA), it provides a clean way to generate the View tree from the Model. Data binding is strictly unidirectional (Read-Only).  
For Path B (Components), it provides a powerful composition tool. Data binding is bidirectional (Read-Write), allowing inputs to automatically update underlying models.  
This layer lowers the barrier to entry. It makes TUI code look like HTML or SwiftUI. It turns verbose Ruby structs into elegant, nested blocks.

## ---

**Chapter 6: Layer 3 — The Framework (ratatui\_ruby-trails)**

### **What's in this Chapter**

* **The Vision:** "Rails for the Terminal."  
* **The Generator:** trails new and the standard app structure.  
* **The Integration:** Wiring ActiveRecord, Configuration, and Environment into the loop.  
* **The Dead End Warning:** Why users must choose their path (TEA or Components) at generation time.

### **Chapter Summary**

Trails is the opinionated framework. It is where the ecosystem coalesces into a product. It eliminates decision fatigue by providing a standard directory structure, a pre-configured build pipeline, and robust integration with the broader Ruby ecosystem.  
Trails is the entry point for the majority of users. It hides the complexity of Layers 1 through 2\. It asks the user a simple question: *"Are you building a Tool (TEA) or a Platform (Components)?"* Based on the answer, it generates the correct scaffolding. It ensures that databases are connected, logs are rotated, and the application boots cleanly. It is the fulfillment of our promise: Professional TUI development in Ruby.

## ---

**Chapter 7: Concurrency & Future Proofing**

### **What's in this Chapter**

* **The Ractor Reality:** Ruby 4.0 is coming. The GIL is fading.  
* **The Trojan Horse Strategy:** Enforcing immutability in v1.x APIs to enable v2.x parallelism.  
* **The Worker Pool:** Separation of UI (Main Thread) and Side Effects (Background Threads).  
* **Thread Safety:** Strict rules for FFI access.

### **Chapter Summary**

We are building software for the future of Ruby. While v1.0 runs on standard Threads, every architectural decision has been made with Ractors (Ruby's parallel execution units) in mind.  
We do not trust the user to write thread-safe code; we enforce it via the runtime. Layer 1.25 (TEA) strictly validates that messages are immutable. Layer 1.5 (Components) isolates state within object boundaries. By imposing these constraints now, we guarantee that ratatui\_ruby applications will scale to multiple cores in v2.0 without a rewrite. We are paying the complexity tax today so our users don't have to pay the refactoring tax tomorrow.

## ---

**Chapter 8: Roadmap & Execution ("The Onion Peel")**

### **What's in this Chapter**

* **Sequential Delivery:** Why we build inside-out, not in parallel.  
* **Phase 1:** The Engine (Done).  
* **Phase 2:** The Tea (Layer 1.25).  
* **Phase 3:** The Kit (Layer 1.5).  
* **Phase 4:** The Syntax (Layer 2).  
* **Phase 5:** The Framework (Layer 3).  
* **The "Batteries Included" Policy:** Shipping core features first, peripherals second.

### **Chapter Summary**

We execute strictly in serial. We do not build the DSL before the Components. We do not build the Components before the Engine is feature-complete. This "Onion Peel" strategy ensures that at every single stage of development, we have a shipping, working product.  
Currently, Layer 1 is complete. Our immediate focus is Layer 1.25 (TEA). This allows us to capture the "Scripting/Tooling" market immediately while we take the time to architect the complex Layer 1.5 (Component) system correctly. We will not rush. We will not cut corners. We build the foundation, then the walls, then the roof.