<!--
  SPDX-FileCopyrightText: 2025 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

This is an exceptionally strong specification. It is lean, idiomatic to Ruby, and fundamentally simpler than the competition because it strips away the unnecessary "Architecture Theater" (Classes for Batches, Interfaces for Commands) in favor of raw Ruby primitives.  
Here is my specific feedback on the design:

### **1\. The "Proc as Command" Pattern is a Winner**

Treating Cmd as just \-\> { return\_msg } is the "killer feature" of this design.

* **Why it works:** It makes the "Batteries Included" module (TEA::Cmd) optional. A user can write their own ad-hoc command (-\> { perform\_custom\_db\_query; :query\_done }) without inheriting from anything or reading documentation.  
* **The Ractor Advantage:** Since Procs in Ruby capture their binding, your "Trojan Horse" check for Ractor.shareable? will be very effective here. It will immediately catch if a user accidentally captures a mutable variable inside their command closure.

### **2\. The Recursive Subscription Model**

Replacing a "Subscription Manager" with "Recursive Commands" is a clever simplification, but it introduces one edge case you must handle: **Cancellation.**

* **The Risk:** If I fire a recursive "Tick" command every 1 second, how do I stop it? In a Subscription model, the runtime diffs the subscriptions and kills the old one. In a "Fire and Forget" model, the command is already in the thread pool.  
* **The Fix:** You don't need to add a Cancellation API. You just document the pattern: The Update function receives the Tick message and **decides whether to fire the next command**. To "cancel," you simply *stop returning the recursive command*.  
* *Verdict:* This works perfectly and keeps the runtime simple.

### **3\. The Cmd.quit Implementation Detail**

In your "Flavor A" example:

Ruby

when :quit then \[model, RatatuiRuby::TEA::Cmd.quit\]

Ensure that Cmd.quit returns a special **Sentinel Value** (like a specific Symbol :\_\_tea\_quit\_\_) rather than just a Proc.

* **Why:** If Cmd.quit is just a Proc, the runtime will spawn a thread to run it. You want the runtime to see that specific command and break the loop immediately, ensuring a clean synchronous exit.

### **4\. Error Handling Strategy**

Your specification doesn't explicitly mention what happens if a Cmd (Proc) raises an Exception.

* **Recommendation:** Wrap the proc.call in the worker thread with a rescue.  
* **The Protocol:** Define RatatuiRuby::TEA::Msg::Error wrapping the exception. Dispatch this back to the main loop. This allows the user's Update function to handle crashes (e.g., show a generic error toast) without crashing the entire TUI.

### **Status Check: The P0 Blocker**

You correctly identified RatatuiRuby.poll\_event(timeout: Float) as the critical dependency.

* Without this, step 2 of your loop blocks forever.  
* **Current State:** ratatui\_ruby (Gem 1\) poll\_event currently blocks indefinitely (or relies on crossterm defaults).  
* **Action:** You must expose the crossterm::event::poll duration parameter in your Rust extension before building this gem.

### **Final Verdict**

**Ship it.** This specification ("Jujube Redux") is the perfect "Gem 1.25." It is small enough to build in a weekend but powerful enough to run production apps. It effectively neutralizes the CharmRuby architecture argument by offering the same paradigm with better performance and cleaner syntax.