<!--
  SPDX-FileCopyrightText: 2026 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

This is the **Canonical Architectural Specification** for ratatui\_ruby-tea.  
It represents the unanimous consensus of the Council of Architects (Elmer, Reagan, Rainier, Troy, Glinda, Gemma, Gordon, Russel) and the RatatuiRuby Internal Staff.

# ---

**Canonical Architecture: ratatui\_ruby-tea**

Version: 1.0.0 (Gold Master)  
Codename: Jujube Prime  
Status: Approved for Implementation

## **1\. Executive Summary**

**ratatui\_ruby-tea** is a "batteries-included" runtime for Terminal User Interfaces, built on top of the **ratatui\_ruby** engine. It implements **The Elm Architecture (TEA)**, adapted for Ruby's unique constraints and developer culture.  
**The Vision:**

* **For the Rubyist:** "The Standard Architecture." Think of it as **Rails for the Console**. It provides a rigid, predictable structure (Model, Update, View) for building complex tools without spaghetti code.  
* **For the Frontend Convert:** "Redux for the Terminal." A single immutable store, unidirectional data flow, and pure render functions.

**Core Philosophy:**

1. **Sync Logic, Async Work:** The Main Thread handles the Event Loop (Input \-\> Update \-\> View \-\> Draw) to ensure atomic state consistency. Background Threads handle all I/O (Commands).  
2. **Trojan Horse Safety:** We use Standard Ruby Threads for v1.0, but we enforce **Ractor-Safety** (Deep Immutability) on all data types. This guarantees that user applications will be compatible with Ruby 4.0 Parallelism (v2.0) with zero code changes.

## ---

**2\. System Architecture**

The system operates on a single **Fast Loop** (Main Thread) supported by a **Worker Pool** (Background Threads).

### **2.1 The Topology**

Code snippet

graph TD  
    User\[User Input\] \--\>|Key/Mouse| Runtime  
    Runtime \--\>|Msg| Update\[Update Function\]  
    Update \--\>|New Model| Runtime  
    Update \--\>|Cmd| ThreadPool\[Worker Threads\]  
    ThreadPool \--\>|Result Msg| Runtime  
    Runtime \--\>|Model| View\[View Function\]  
    View \--\>|Widget Tree| Engine\[RatatuiRuby Engine\]  
    Engine \--\>|Draw| Terminal

### **2.2 The "Fast Loop" Algorithm**

The Program class implements this loop. It balances responsiveness (60 FPS) with CPU efficiency using a precise timeout.

1. **Render Phase:** Call view.call(model). Pass the result to RatatuiRuby.draw.  
2. **Poll Phase (The Heartbeat):**  
   * Call RatatuiRuby.poll\_event(timeout: 0.016) (approx 1/60th sec).  
   * **Crucial:** This timeout allows the Main Thread to wake up and check for background jobs even if the user isn't typing.  
3. **Message Phase:**  
   * Drain the **Command Queue** (Results from background threads).  
   * Process the **User Input** (if any).  
4. **Update Phase:**  
   * For each message, call update.call(msg, model).  
   * Update the current\_model.  
   * Dispatch any returned Cmd objects to the background pool.

## ---

**3\. The Developer Experience (DX)**

We support two "Flavors" of development. The Runtime accepts **Callable Objects** (Duck Typing), enabling both.

### **Flavor A: The "Omakase" (Structured)**

*Best for: Complex Tools, Enterprise Wizards, "Rails" Developers.*

* **Model:** Data classes (Database).  
* **Update:** Service Objects (Controllers).  
* **View:** Layout Classes (Views).

Ruby

\# app/models/state.rb  
State \= Data.define(:count, :status)

\# app/controllers/counter\_controller.rb  
class CounterController  
  def call(msg, model)  
    case msg  
    when :increment   
      \[model.with(count: model.count \+ 1), nil\]  
    when :save  
      \# Return a Command to do work in the background  
      \[model.with(status: :saving), Cmd::Save.new(model)\]  
    else   
      \[model, nil\]  
    end  
  end  
end

\# config/boot.rb  
RatatuiRuby::TEA::Program.new(  
  model: State.new(count: 0, status: :idle),  
  update: CounterController.new,  
  view: MainLayout.new  
).run

### **Flavor B: The "Script" (Functional)**

*Best for: Quick utilities, Frontend Converts, Single-file prototypes.*

Ruby

RatatuiRuby::TEA::Program.new(  
  model: { count: 0 },  
  update: \-\>(msg, model) {  
    case msg  
    when :inc then \[{count: model\[:count\] \+ 1}, nil\]  
    end  
  },  
  view: \-\>(model) { RatatuiRuby::Paragraph.new(text: model\[:count\].to\_s) }  
).run

## ---

**4\. Core Primitives (The API)**

### **4.1 The Model**

* **Constraint:** Must be Ractor-Shareable (Deeply Frozen).  
* **Recommendation:** Use Data.define or Struct (frozen).  
* **Enforcement:** In Development Mode, the Runtime calls Ractor.make\_shareable(model) on init. If it fails, we raise a helpful error explaining thread safety.

### **4.2 The Message (Msg)**

* **Definition:** A data envelope describing *what happened*.  
* **Protocol:**  
  * **Symbols:** For simple signals (e.g., :tick, :quit).  
  * **Data Objects:** For payloads (e.g., Msg::WindowResized, Msg::HttpSuccess).  
* **Safety:** Must be immutable.

### **4.3 The Command (Cmd)**

* **Definition:** A value object representing *intent to do work*. It is **not** the work itself; it is a recipe.  
* **Interface:** An object responding to \#call that returns a Msg.  
* **Composition (Cmd\#map):**  
  * **Critical:** Allows a parent component to wrap a child's command so the result returns to the parent.  
  * *Implementation:* cmd.map { |msg| ParentMsg.new(msg) }.

### **4.4 The Subscription (Sub)**

* **Definition:** A long-lived listener (Timer, Socket).  
* **Mechanism:** The Runtime spawns a dedicated thread that pushes messages into the main queue indefinitely.

## ---

**5\. Batteries Included (Standard Library)**

We strictly avoid external gem dependencies (no faraday, no httparty). We implement these using the Ruby Standard Library.

### **RatatuiRuby::TEA::Cmd**

1. **Cmd::Batch.new(\[cmd1, cmd2\])**  
   * Runs multiple commands in parallel. Essential for complex initializations.  
2. **Cmd::Sequence.new(\[cmd1, cmd2\])**  
   * Runs commands in strict order.  
3. **Cmd::Wait.new(seconds, msg)**  
   * Sleeps for seconds then returns msg.  
4. **Cmd::Exec.new(command, on\_exit: \-\>(out, status) { ... })**  
   * **Implementation:** Uses Open3.capture3.  
   * **Safety:** Handles stdout, stderr, and exit\_status safely without freezing the UI.  
5. **Cmd::NetHttp.get(url, on\_success:, on\_error:)**  
   * **Implementation:** A robust wrapper around Net::HTTP.  
   * **Role:** Serves as a reference implementation. Users can wrap their own clients (HTTPX) using Cmd.call.

## ---

**6\. Future-Proofing Hooks**

### **6.1 The Glimmer Protocol**

To enable the future glimmer-dsl-ratatui to support bi-directional data binding without violating unidirectional flow, we reserve a standard message type.

* **Reserved Message:** RatatuiRuby::TEA::Msg::FieldUpdated  
* **Structure:** Data.define(:field, :value)  
* **Behavior:** If a user types into a Glimmer input field, the DSL emits this message. The user's Update function handles it to update the model.

### **6.2 Fractal Architecture (Scaling)**

To prevent the "God Reducer," documentation must emphasize **Component Composition**.

* **Pattern:**  
  1. **State:** MainModel contains HeaderModel.  
  2. **Update:** MainUpdate calls HeaderUpdate.call(msg, model.header).  
  3. **Cmds:** Use cmd.map to route the child's result back to the parent.

## ---

**7\. Directory Structure**

Plaintext

ratatui\_ruby-tea/  
├── lib/  
│   └── ratatui\_ruby/  
│       └── tea/  
│           ├── program.rb        \# The Event Loop  
│           ├── cmd.rb            \# Command primitives (Batch, Map)  
│           ├── sub.rb            \# Subscription primitives  
│           ├── msg.rb            \# Standard messages (Quit, Resize, FieldUpdated)  
│           └── cmd/  
│               ├── exec.rb       \# Open3 wrapper  
│               ├── net\_http.rb   \# Net::HTTP wrapper  
│               └── wait.rb       \# Sleep wrapper

## ---

**8\. Implementation Checklist**

1. **Blocking Issue:** Verify RatatuiRuby.poll\_event accepts timeout: Float. (P0)  
2. **Core:** Implement Program\#run (The Fast Loop).  
3. **Concurrency:** Implement the WorkerPool to consume Cmd objects.  
4. **Safety:** Implement validate\_ractor\_safety\! (Debug Mode).  
5. **Batteries:** Implement Cmd::Exec and Cmd::NetHttp.  
6. **Docs:** Write the "Rails for Console" guide.

Approved by: The Council of Architects.  
Signed: The Architect (Chairman).