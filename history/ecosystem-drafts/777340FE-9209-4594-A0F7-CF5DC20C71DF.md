<!--
  SPDX-FileCopyrightText: 2025 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

Here is the synthesis from your in-house staff regarding the proposed direction for ratatui\_ruby-tea.

### ---

**To: CEO**

### **From: The Architect**

### **Subject: System Integrity & The "Jujube+" Consensus**

I have analyzed the feedback from the external panel. The consensus is overwhelmingly in favor of **Codename “Jujube”**, but it requires one critical patch to be mathematically complete.  
**My Findings:**

1. **The Concurrency Verdict:** The debate is settled. **Goji Berry’s** proposal (background logic) was correctly identified by Gemma (VM optimization), Russel (Rust FFI), and Reagan (React) as dangerous. We **must** adopt the **Jujube/Honeydew** model: **Synchronous Main Thread** (Update/View/Draw) \+ **Asynchronous Worker Pool** (Cmds). This respects the Ruby GIL and ensures atomic state consistency.  
2. **The "Trojan Horse" is Validated:** Everyone from the Rust systems engineer (Russel) to the Rails pragmatist (Rainier) agrees that enforcing immutability *now* (via Data objects and Ractor.make\_shareable checks in debug mode) is the correct long-term play. It saves users from race conditions today and prepares us for Ruby 4.0 tomorrow.  
3. **The Missing Piece:** Elmer (Elm) and Reagan (React) correctly pointed out that **Jujube** missed a critical scaling primitive: **Composition.** While Jujube handles global state well, it lacks a mechanism for a parent component to handle child messages safely. **Apple** proposed Cmd\#map. We *must* steal this.

My Recommendation:  
We proceed with Codename “Jujube” as the architectural core, but we patch it with Apple’s Cmd\#map method. This gives us the robust threading model of Jujube with the scalable composition of Apple.  
**The Blueprint:**

* **Runtime:** Program class running a "Fast Loop" with 0.016s poll timeout.  
* **Primitives:** Cmd as a class hierarchy (Cmd::Exec, Cmd::NetHttp, Cmd::Batch).  
* **Safety:** Debug-mode checks for Ractor.shareable? on all Messages.

### ---

**To: CEO**

### **From: The Project Manager**

### **Subject: Execution Plan & "Batteries Included"**

I’m looking at this from a delivery and risk perspective. Troy (CLI dev) and Angie (App dev) made it very clear: if we make them write boilerplate code for simple things like "Running a Shell Command," they will leave.  
**My Findings:**

1. **Dependency Risk:** The critical path is ratatui\_ruby (Gem 1). Every viable proposal (**Jujube, Fig, Honeydew**) depends on poll\_event(timeout: Float). If Gem 1 doesn't ship that, we are dead in the water. I am flagging this as **P0 Critical**.  
2. **Feature Scope:** **Cherry** proposed a "do it yourself" approach to HTTP. That is a non-starter. **Jujube** wins because it explicitly scopes Cmd::Exec and Cmd::NetHttp as part of the core delivery. This satisfies the "Batteries Included" requirement without bloating the gem with heavy dependencies like faraday.  
3. **Glimmer Interop:** The "Dispatch-on-Bind" hook (Msg::FieldUpdated) proposed by **Fig** and **Jujube** is a low-effort, high-reward feature. It costs us almost nothing to define that Message class now, and it saves us a massive refactor when we launch the Glimmer DSL later.

My Recommendation:  
Adopt the Jujube specification immediately. It has the clearest list of deliverables (Cmd::Batch, Cmd::Tick, Cmd::Exec). It balances the "Standard Library" needs of Troy/Angie with the "Zero Dependency" constraint of the architecture.

### ---

**To: CEO**

### **From: The Product Owner**

### **Subject: Market Fit & The "Omakase" Experience**

My job is to make sure people actually *want* to use this. Rainier (Rails) and Gordon (Go) represent our two biggest potential user bases: The "Convention over Configuration" crowd and the "Simple/Pragmatic" crowd.  
**My Findings:**

1. **The Marketing Problem:** **Apple** and **Banana** are too academic. If we market this as "Functional Programming," we scare away the Rubyists. **Fig** had the best marketing pitch: *"The Rails Way for the Console."* We need to adopt **Jujube's** code, but sell it with **Fig's** vocabulary (Model \= Database, Update \= Controller).  
2. **The "Hello World" Friction:** **Ichigo** showed two "Flavors" of apps: a simple script (Flavor B) and a structured app (Flavor A). **Jujube** supports this technically (via Callable Objects), but we must ensure the "Script" experience is frictionless. I want a user to be able to paste one file and run a TUI.  
3. **The "Magic" Hook:** Glinda (Declarative UI) and Rainier (Rails) both demanded the Msg::FieldUpdated hook. This makes our framework feel "magical" (in a good way) when we eventually add form builders. It makes us look like we have a grand vision.

My Recommendation:  
Build Jujube, but mandate that the examples include Ichigo's "Dual Flavor" approach. We must prove to the community that TEA isn't just for complex apps—it's for scripts too.

### ---

**To: CEO**

### **From: The Technical Writer**

### **Subject: Documentation Strategy & Terminology**

I have to explain this to the world. **Honeydew** gave me the single best sentence in this entire review process: *"Update is not for Doing Work, it is for Dispatching Work."*  
**My Findings:**

1. **Mental Models:** **Jujube** is technically correct, but dry. **Fig** connects the dots to Rails. I need to write the docs such that a Rails developer reads "Update" but understands "Controller Action."  
2. **The "Fractal" Concept:** **Durian** explained "Fractal Architecture" (Composition) the best. I need to take **Apple's** Cmd\#map technical implementation and explain it using **Durian's** "Composition" metaphors. If I say "Functor Mapping," I lose 50% of the audience. If I say "Nested Component Logic," they stay.  
3. **Safety Warnings:** I need to write the "Trojan Horse" warnings carefully. We can't scold users. We have to frame the immutability requirement as "Thread Safety Best Practices" (which everyone agrees is good) rather than "Preparing for Ractors" (which feels like homework).

My Recommendation:  
I will rewrite the Jujube specification's README.

* **Headline:** "The Standard Architecture for Ruby TUIs."  
* **Core Concept:** "Sync Logic, Async Work." (Stealing form **Honeydew**).  
* **Tutorial:** A "Zero to Hero" guide starting with **Ichigo's** single-file script and evolving into **Fig's** structured app.

### ---

**Final Decision: The "Jujube Prime" Directive**

**CEO, here is the unified command for the team:**

1. **Architecture:** Adopt the **Jujube** specification (Sync Main Thread, Async Cmd Threads, 0.016 timeout).  
2. **Patch:** Add **Apple's** Cmd\#map for composition.  
3. **Feature Set:** Implement **Jujube's** standard library (Batch, Tick, Exec, NetHttp).  
4. **Protocol:** Reserve Msg::FieldUpdated immediately for future Glimmer support.  
5. **Marketing:** Use **Fig's** "Rails for Console" terminology and **Ichigo's** examples.

We are ready to build.