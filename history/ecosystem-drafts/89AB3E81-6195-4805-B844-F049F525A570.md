<!--
  SPDX-FileCopyrightText: 2026 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

Here is the unified **Ecosystem Strategy & Architecture Decision Record**. This document serves as the constitution for the RatatuiRuby project. It synthesizes the "Big Tent" strategy, the "Jujube Redux" specification for TEA, and the Frame-based rendering architecture established in v1.0.0.

# ---

**The RatatuiRuby Ecosystem Strategy**

Version: 2.0 (The Constitution)  
Status: Ratified  
Scope: v1.0.0 through v3.0.0

## ---

**Chapter 1: The "Big Tent" Vision**

### **What's in this Chapter**

* **The Core Philosophy:** Why we reject the choice between "Functional" and "Object-Oriented."  
* **The Forked Path:** How one engine supports two distinct application architectures.  
* **The Target Audience:** Serving both the script writer and the platform engineer.

### **Chapter Summary**

We are building the universal runtime for Ruby terminal interfaces. Historically, developers have had to choose a language based on their preferred architecture: Go (Bubble Tea) for functional patterns, or Java/C\# for object-oriented components. We reject this trade-off.  
Context: Ruby is a multi-paradigm language.1 It supports functional pipelines and strict object hierarchies with equal grace.  
Problem: Existing TUI libraries force a single paradigm. Wrapping a React-like component system in a functional loop is clumsy. Forcing global state management on a simple script is overkill.  
Solution: We implement a "Forked Path" strategy.  
The ecosystem shares a single, high-performance engine (Layer 1). Immediately above this layer, the path splits. **Path A** (The Tea) serves developers who prefer immutable state and pure functions. **Path B** (The Kit) serves developers who prefer encapsulated state and mutable objects. Both paths converge again at the DSL layer, allowing Glimmer to describe interfaces for either architecture. We do not judge the developer's preference. We provide the best possible implementation of both.

## ---

**Chapter 2: The Ecosystem Map**

### **What's in this Chapter**

* **Taxonomy:** The four layers of the stack.  
* **Naming Conventions:** Standards for internal names, gem names, and require paths.  
* **Dependency Graph:** How the layers interact without circular dependencies.

### **Chapter Summary**

The ecosystem is organized into layers of increasing abstraction. Each layer solves a specific problem and hides the complexity of the layer below it.

* **Layer 1: The Engine (ratatui\_ruby).** The stateless renderer. It wraps the Rust Ratatui library. It handles FFI, event polling, and raw drawing.  
* **Layer 1.25: The Functional Runtime (ratatui\_ruby-tea).** A lightweight implementation of The Elm Architecture. It relies on Layer 1 for rendering but manages state externally.  
* **Layer 1.5: The Component Kit (ratatui\_ruby-components).** A retained-mode system. It defines Component classes, handles focus management, and routes events.  
* **Layer 2: The Syntax (glimmer-dsl-ratatui).** A declarative DSL. It wraps both Layer 1.25 (Views) and Layer 1.5 (Components).  
* **Layer 3: The Framework (ratatui\_ruby-trails).** The "Rails" layer. It provides scaffolding, database integration, and conventions.

We use specific naming conventions to ensure discoverability. The engine and runtimes use the ratatui\_ruby namespace. The DSL uses glimmer-dsl- to align with the Glimmer ecosystem.

## ---

**Chapter 3: Layer 1 — The Engine**

### **What's in this Chapter**

* **The Frame API:** The imperative rendering model (draw { |frame| ... }).  
* **Immediate Mode:** Why we rebuild the tree every frame.  
* **Rust Parity:** Mapping Rust structs to Ruby Data objects.  
* **Primitives:** Text measurement, cursor control, and event polling.

### **Chapter Summary**

Context: Ratatui (Rust) is an immediate-mode library.2 It draws the entire screen from scratch on every frame.  
Problem: Ruby developers are used to retained objects. Bridging these worldviews requires a robust interface that does not hide the underlying mechanics.  
Solution: We expose the Frame API.  
RatatuiRuby (v1.0.0) is the engine. It is stateless. It does not know what a "button" is. It only knows about geometric primitives. We expose a draw method that yields a Frame. The developer uses this frame to render widgets into specific Rect areas.  
This design is intentional. It forces the separation of **Layout** (calculating where things go) from **Rendering** (drawing them). By calculating layout explicitly and passing the resulting Rects to the renderer, we solve the "Hit Testing" problem. The same Rect used to draw a sidebar is cached and used to detect mouse clicks. This layer is complete, fast, and thread-safe.

## ---

**Chapter 4: Layer 1.25 — Path A (The Tea)**

### **What's in this Chapter**

* **Jujube Redux:** The specification for the functional runtime.  
* **Callable Objects:** Rejecting base classes in favor of Procs and Lambdas.  
* **Concurrency:** The "Sync Logic, Async Work" pattern.  
* **The Trojan Horse:** Preparing for Ractors by enforcing immutability now.

### **Chapter Summary**

Context: Many developers prefer the simplicity of The Elm Architecture: Model, Update, View.  
Problem: Implementing this in Ruby often leads to slow main loops or unsafe threading.  
Solution: We build ratatui\_ruby-tea.  
This gem implements the "Jujube Redux" specification. It is a strict implementation of unidirectional data flow. It rejects inheritance. You do not subclass App. Instead, you pass **Callable Objects** (Procs or Service Objects) to the runtime.  
The runtime enforces a strict separation of concerns. Logic (Update/View) runs synchronously on the main thread to guarantee 60 FPS. Side effects (HTTP, Disk I/O) run asynchronously on a worker pool. To prepare for Ruby 4.0's parallelism features, the runtime enforces that all Messages and Models must be **Ractor-shareable** (deeply frozen). We do not wait for Ractors to stabilize; we enforce the discipline today so the switch will be transparent tomorrow.

## ---

**Chapter 5: Layer 1.5 — Path B (The Components)**

### **What's in this Chapter**

* **Retained Mode:** Simulating stateful objects on top of a stateless engine.  
* **The Component Lifecycle:** Mount, Render, Update, Unmount.  
* **Focus Management:** Handling Tab cycles and keyboard routing.  
* **Frame Interaction:** How components draw themselves using the Layer 1 API.

### **Chapter Summary**

Context: Enterprise applications require complex state. A globally reducer (Path A) becomes unmanageable when building a dashboard with fifty interactive widgets.  
Problem: The Engine is stateless. It forgets the widget exists as soon as it is drawn.  
Solution: We build ratatui\_ruby-components.  
This layer introduces the **Component** class. Components are retained Ruby objects. They persist in memory across frames. They hold their own state (e.g., @is\_focused, @input\_value).  
The Component layer acts as a factory. Every frame, it walks the object tree. Each component calculates its size and draws itself using the Layer 1 Frame API. The system includes a **Focus Manager** that tracks which component is active and routes keyboard events exclusively to it. This allows developers to build complex, encapsulated UIs—like form libraries or data grids—without polluting the global namespace.

## ---

**Chapter 6: Layer 2 — The Syntax (Glimmer)**

### **What's in this Chapter**

* **Declarative UI:** Replacing manual object construction with a DSL.  
* **Unification:** How one syntax supports both TEA Views and Component Trees.  
* **Data Binding:** The distinction between Unidirectional (TEA) and Bidirectional (Components) binding.

### **Chapter Summary**

Context: Constructing UI trees manually in Ruby is verbose. Nesting objects inside arrays leads to "rightward drift" and unreadable code.  
Problem: Developers want the expressiveness of HTML or SwiftUI.  
Solution: We build glimmer-dsl-ratatui.  
This gem provides a unified syntax for the ecosystem. It wraps both the functional views of Path A and the object trees of Path B.  
For Path A (TEA), the DSL is strictly a view generator. It takes the Model and returns a Layer 1 render tree. Data binding is unidirectional; the view reflects the model, but cannot mutate it directly.  
For Path B (Components), the DSL is a tree builder. It instantiates Component objects and wires them together. Data binding is bidirectional; a change in the UI (typing in a box) automatically updates the underlying Ruby object. This layer proves the power of the architecture: the syntax is identical, even though the underlying engines are radically different.

## ---

**Chapter 7: The Roadmap & Positioning**

### **What's in this Chapter**

* **The "Onion Peel" Strategy:** Releasing layers sequentially to ensure quality.  
* **Competitive Analysis:** Positioning against CharmRuby, Rust, and Go.  
* **Marketing Personas:** Tailoring the pitch to Junior Devs, Frontend Devs, and Architects.

### **Chapter Summary**

Context: The market has established competitors (CharmRuby) and entrenched alternatives (Raw Rust/Go).  
Problem: We must define why a developer should choose RatatuiRuby.  
Solution: We execute a disciplined rollout and clear messaging.  
We adopt the **"Onion Peel"** roadmap. We do not build everything at once. We finish the Engine first. Then we ship the TEA runtime (Path A) to capture the scripting market. Then we ship the Component Kit (Path B) to capture the application market. Finally, we ship the DSL to unify them.  
Our positioning is aggressive but respectful.  
Vs. CharmRuby: We offer native performance. We do not bridge a garbage-collected Go runtime into Ruby. We use Rust.  
Vs. Rust: We offer iteration speed. You get the renderer without the borrow checker.  
Vs. Go: We offer the Ruby ecosystem. You keep your ActiveRecord models and your RSpec tests.  
We are not just a wrapper. We are the Rails of the Terminal.