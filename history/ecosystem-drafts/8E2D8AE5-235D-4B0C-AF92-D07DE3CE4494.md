<!--
  SPDX-FileCopyrightText: 2026 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

Here is the comprehensive **Ecosystem Strategy & Architecture Record**. This document unifies the "Big Tent" strategy, the Frame-Based Rendering API (Proposal 3), and the "Jujube Redux" specification for the TEA runtime.  
This text serves as the **Constitution** for the RatatuiRuby project. It defines not just what we build, but why and how.

# ---

**The RatatuiRuby Constitution: Ecosystem Strategy & Architecture**

Version: 2.0 (The "Big Tent" Unification)  
Status: Ratified  
Scope: Gems 1, 1.25, 1.5, 2, and 3

## **Abstract**

We are building the universal Terminal User Interface (TUI) runtime for Ruby. We reject the false choice between "Functional" and "Object-Oriented" programming. Instead, we provide a single, high-performance Rust engine that powers two distinct architectural paths: the functional **Elm Architecture** (Path A) and the object-oriented **Component Kit** (Path B). This document details the technical and philosophical boundaries of this ecosystem.

## ---

**Chapter 1: The "Big Tent" Strategy**

### **What’s in This Chapter**

* The "Forked Path" architecture: Supporting two mutually exclusive paradigms.  
* The naming convention: Engine, TEA, Components, DSL, and Framework.  
* The "Trojan Horse" concurrency strategy (Threads today, Ractors tomorrow).  
* The unified versioning strategy.

### **Chapter Summary**

We do not force developers to think like us. We allow them to choose their paradigm.  
The ecosystem is built on a "Forked Path." At the bottom lies **RatatuiRuby (The Engine)**. It is shared. It is stateless. It is fast. Above it, the road splits.  
**Path A** is for the functional programmer. It uses **ratatui\_ruby-tea**. It follows The Elm Architecture. State is a single immutable data structure. Logic is a pure function. It is ideal for CLI tools, wizards, and state machines.  
**Path B** is for the object-oriented programmer. It uses **ratatui\_ruby-components**. It follows the Retained Mode pattern. State is distributed across objects. Logic is encapsulated in classes. It is ideal for dashboards, complex forms, and enterprise applications.  
Both paths are valid. Both run on the same metal. By supporting both, we capture the entire Ruby market—from the script writer to the platform engineer—without compromising the integrity of either approach.

## ---

**Chapter 2: The Engine (Gem 1\)**

### **What’s in This Chapter**

* The Rust/Ruby boundary: Why we use FFI and magnus.  
* The **Frame API** (Proposal 3): Explicit rendering control (frame.render).  
* The **Declarative Overload**: Backward compatibility for tree-based rendering.  
* The "Missing 4" Primitives: Text Width, Cursor Positioning, Modifiers, and Resize Events.

### **Chapter Summary**

The Engine is the foundation. It must be unopinionated. It must not know what a "Button" is. It must not know what "Focus" is. It only knows geometry and drawing.  
We use **Rust** to ensure performance. The terminal requires 60 frames per second. Ruby cannot do the heavy lifting of layout calculations (Cassowary algorithm) and buffer diffing at that speed without stalling. Rust handles the math. Ruby handles the logic.  
We expose two APIs to the upper layers. The **Declarative API** (draw(tree)) allows the user to pass a static tree of data. This powers Path A (TEA). The **Frame API** (draw { |frame| ... }) gives the user imperative control over where widgets are drawn. This powers Path B (Components), enabling precise hit-testing and layout caching. The Engine is the "metal" upon which the rest of the ecosystem stands.

## ---

**Chapter 3: Path A — The Functional Runtime (Gem 1.25)**

### **What’s in This Chapter**

* The "Jujube Redux" Specification: Radical simplicity.  
* **Sync Logic, Async Work**: The event loop architecture.  
* **Callable Objects**: Rejecting base classes in favor of Procs and Lambdas.  
* Fractal Architecture: Composition without monolithic reducers.  
* Ractor Safety: Enforcing immutability in Debug Mode.

### **Chapter Summary**

Simplicity is the ultimate sophistication. **ratatui\_ruby-tea** is a runtime for The Elm Architecture that rejects the complexity of traditional Ruby frameworks.  
We do not use inheritance. There is no Application base class. Instead, the runtime accepts **Callable Objects** (Procs). The user provides an update function and a view function. The runtime turns the crank.  
We enforce a strict separation of concerns. **Logic** (updating the model) happens synchronously on the main thread. **Work** (HTTP requests, database queries, shell commands) happens asynchronously on a worker thread. Communication happens via **Messages**.  
We are building for the future. While the runtime uses Threads today, it enforces **Ractor Safety** now. In Debug Mode, we verify that every Message and Model is deeply frozen. When Ruby 4.0's Ractors mature, we will swap the backend engine without breaking a single line of user code.

## ---

**Chapter 4: Path B — The Component Kit (Gem 1.5)**

### **What’s in This Chapter**

* The Component Lifecycle: Mount, Update, Render, Unmount.  
* **Focus Management**: Tabbing, reverse-tabbing, and focus traps.  
* **Hit Testing**: Using the Frame API to route mouse events.  
* State Distribution: Why components own their data.  
* The "View Generation" Bridge: Generating Layer 1 structs from Layer 2 objects.

### **Chapter Summary**

Path A manages state globally. Path B manages state locally. **ratatui\_ruby-components** introduces the concept of the "Widget."  
A Widget is a Ruby object that persists in memory. It knows if it is focused. It knows if it is hovered. It listens for events. Crucially, it relies on the Engine's **Frame API** to function. When a component renders, it tells the Engine *exactly* where it is drawing (frame.render(widget, area)). It stores that area. When a mouse click occurs, the component checks its stored area to decide if it was clicked.  
This layer restores the Object-Oriented principles Rubyists love. You can subclass Button. You can mix in Clickable. You can encapsulate complex behavior behind simple interfaces. It bridges the gap between the stateless rendering engine and the stateful needs of complex applications.

## ---

**Chapter 5: The Syntax Layer (Gem 2\)**

### **What’s in This Chapter**

* **Glimmer DSL**: Adapting the desktop GUI syntax to the terminal.  
* **Bi-directional vs. Uni-directional**: Handling the two paths.  
* Implicit Tree Building: vertical\_layout { button }.  
* Signal Wiring: on\_clicked { ... }.

### **Chapter Summary**

Code should look like the UI it describes. **glimmer-dsl-ratatui** is the syntax layer that makes this possible. It removes the visual noise of instantiating classes and managing arrays.  
This layer is intelligent. It detects which Path you are using and adapts.  
If you are on Path A (TEA), the DSL is Uni-directional. It is syntactic sugar for generating the View Tree. It cannot mutate state.  
If you are on Path B (Components), the DSL is Bi-directional. It binds variables to widgets (value \<= \[model, :name\]). It wires signals to slots.  
This is the "User Interface" of our framework. It allows developers to sketch screens as fast as they can type, focusing on hierarchy and structure rather than syntax and punctuation.

## ---

**Chapter 6: The Competitive Landscape**

### **What’s in This Chapter**

* **Vs. CharmRuby**: Porting vs. Native Implementation.  
* **Vs. Raw Rust**: Framework vs. Library.  
* **Vs. Raw Go**: Expression vs. Pragmatism.  
* The "No-Brainer" Proposition: Performance \+ Ergonomics.

### **Chapter Summary**

We respect our competitors, but we offer a distinct advantage.  
**CharmRuby** is an excellent port of Go libraries. However, it bridges two runtimes (Ruby and Go), incurring overhead and complexity. **RatatuiRuby** uses a native Rust extension. We have no runtime overhead. We have no garbage collector fighting Ruby. We offer superior performance and stability.  
**Raw Rust** (Ratatui) is powerful but verbose. It requires manual memory management and strict ownership. We give developers that same power but wrap it in Ruby's expressive joy. We handle the ownership. You handle the design.  
**Raw Go** (Bubble Tea) is efficient but rigid. We offer the same architecture (via Path A) but within the Ruby ecosystem. You keep your gems. You keep your Active Record. You keep your RSpec. You do not have to leave your language to build world-class tools.

## ---

**Chapter 7: Contribution & Ethics**

### **What’s in This Chapter**

* The Alexandrian Form: Context, Problem, Solution.  
* The "No Magic" Rule: Explicit over Implicit.  
* Documentation Standards: Federal Plain Language Guidelines.  
* The Code of Conduct: Professionalism and Patience.

### **Chapter Summary**

We build software for humans. Our code is only as good as our documentation. We reject "magic" behavior that confuses the user. If a feature cannot be explained in simple English, it should not exist.  
We write documentation that respects the reader's time. We use short sentences. We use active voice. We solve problems. When we contribute code, we ensure it fits the architecture. We do not mix Path A and Path B. We respect the boundaries.  
We are stewards of this ecosystem. We build tools that empower others to create beautiful, functional, and accessible software. We are RatatuiRuby.