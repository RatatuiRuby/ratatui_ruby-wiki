<!--
  SPDX-FileCopyrightText: 2026 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

Here is the comprehensive architectural and strategic decision record, synthesizing the recent leadership summit regarding the ratatui\_ruby ecosystem.

# ---

**Decision Record: The "Big Tent" Ecosystem Strategy**

Date: December 30, 2025  
Status: Approved for Implementation

## **1\. Executive Summary: The "Forked Path" Architecture**

The ratatui\_ruby ecosystem will not force a single paradigm. Instead, it will implement a **"Forked Path"** strategy. After the shared engine (Layer 1), the ecosystem splits into two mutually exclusive application architectures.

* **Path A (Functional):** The Elm Architecture (TEA). Optimized for tools, CLI utilities, and complex state machines.  
* **Path B (Object-Oriented):** Component-based Retained Mode. Optimized for dashboards, enterprise platforms, and "Rails-like" development.

## **2\. Gem Taxonomy & Naming Standards**

We have adopted a hybrid naming convention to respect both RubyGems scoping and the Glimmer ecosystem standards.

| Layer | Internal Name | Official Gem Name | Require Path | Role |
| :---- | :---- | :---- | :---- | :---- |
| **1** | Engine | ratatui\_ruby | ratatui\_ruby | Stateless Renderer / FFI |
| **1.25** | TEA | ratatui\_ruby-tea | ratatui\_ruby/tea | Functional Runtime |
| **1.5** | Components | ratatui\_ruby-components | ratatui\_ruby/components | Stateful Widget Kit |
| **2** | DSL | glimmer-dsl-ratatui | glimmer-dsl-ratatui | Declarative Syntax |
| **3** | Framework | ratatui\_ruby-trails | ratatui\_ruby/trails | MVC Framework |

**Note:** glimmer-dsl-ratatui was chosen over ratatui\_ruby-glimmer to ensure auto-discovery within the Glimmer ecosystem.

## **3\. Layer 1: The Engine (Critical Updates)**

Before Gem 1.25 can ship, Gem 1 (ratatui\_ruby) requires a critical update to support non-blocking loops.

### **The Blocker (P0 Priority)**

* **Problem:** Current poll\_event blocks indefinitely. Background threads in TEA cannot update the UI until a key is pressed.  
* **Solution:** Modify Rust extension (src/events.rs) to implement poll\_event(timeout: Float).  
  * Implementation: Wrap crossterm::event::poll.  
  * Behavior: timeout: 0.0 is non-blocking; timeout: nil is blocking.

### **Additional Requirements**

* **Resize Events:** Must reliably emit { type: :resize, width: w, height: h } to support fluid layouts in TEA.  
* **The "Missing 4":** Finish implementing Text Width, Cursor Positioning, Modifiers, and Resize handling.

## **4\. Layer 1.25: TEA Runtime Design**

**Goal:** A production-grade implementation of The Elm Architecture.

### **Concurrency Strategy: "The Trojan Horse"**

* **v1.x Runtime:** Uses Thread and Queue for stability and compatibility.  
* **Forward Compatibility:** We enforce **Ractor-safety** immediately. The Program class will validate that Model and Msg objects are Ractor-shareable (deeply frozen) at startup.  
* **v2.0 Plan:** The engine will transparently swap Threads for Ractors. User code will not need to change because it was forced to be thread-safe from day one.

### **API Design: Callable Objects**

* **Decision:** We rejected the "Base Class" approach (class App \< TEA::App).  
* **Decision:** We adopt **Callable Objects**. The update and view parameters accept any object that responds to \#call.  
  * *Simple:* Pass a Lambda/Proc.  
  * *Structured:* Pass a stateless Service Object (UpdateLogic.new).

### **Batteries Included Strategy**

* **Core:** Ship standard Cmd primitives using only the Ruby Standard Library: Cmd.wait, Cmd.tick, Cmd.exec (shell).  
* **HTTP:** Do **not** bake in faraday or httparty.  
  * Ship a generic Cmd.call wrapper.  
  * Ship a built-in reference implementation using Net::HTTP.  
  * Ship a separate example gem/repo: ratatui\_ruby-tea-httpx as a "Pro" reference implementation.

### **Scaling Strategy (The "God Reducer" Risk)**

* **Pattern:** **Fractal Architecture**.  
* **Documentation:** We will teach users to slice State and delegate Update logic (Composition) immediately in the "Getting Started" guide to prevent massive case statements.

## **5\. Layer 2: Glimmer & Components**

**Scope Decision:** Glimmer DSL support for TEA was approved but deprioritized to a specific rollout phase.

### **Interaction with TEA**

* glimmer-dsl-ratatui will support TEA Views.  
* **Constraint:** Bi-directional data binding (\<=) is **disabled** for TEA. It is strictly syntax sugar for rendering the View tree.

## **6\. Implementation Roadmap (The "Onion Peel")**

We will not work in parallel. We will execute in this strict serial order to ensure deliverable software at every stage:

1. **Gem 1 Blocker:** Fix poll\_event (Rust).  
2. **Ship TEA:** Release ratatui\_ruby-tea v1.0.  
3. **Components (Beta):** Ship ratatui\_ruby-components supporting *only* Custom Components (no built-ins).  
4. **Glimmer (Beta 1):** Ship glimmer-dsl-ratatui supporting Uni-directional binding for TEA and Custom Components.  
5. **Glimmer (Beta 2):** Add Bi-directional binding for Components.  
6. **Standard Kit:** Iteratively release built-in components (Button, Input) one by one, adding Glimmer support for each as they ship.

## **7\. Product Positioning & Messaging**

We market the "Big Tent" via four specific angles, depending on the user persona.

| Persona | The Pitch |
| :---- | :---- |
| **Junior Dev** | **Safety vs. Speed.** "TEA is a checklist (hard to mess up). Components are LEGOs (fast to build)." |
| **Frontend Dev** | **Redux vs. React.** "TEA is Redux (pure logic). Components are React (stateful UI trees)." |
| **Polyglot** | **Expression Problem.** "Use TEA for event-driven tools. Use Components for object-oriented platforms." |
| **Omakase Rubyist** | **The Doctrine of State.** "TEA is the 'Rails Way' for the console. Model \= Database in RAM. Update \= Controller Actions. View \= View." |

---

**Next Immediate Action:** Application Developer to begin Rust implementation of poll\_event timeout.