<!--
  SPDX-FileCopyrightText: 2026 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

This is the **RatatuiRuby Ecosystem Constitution**.  
It unifies the "Big Tent" Strategy, the "Jujube Redux" Specification, and the "Frame API" (Proposal 3\) into a single authoritative document. It deprecates all numeric codenames (Gem 1, 1.25, 1.5, 2, 3\) in favor of semantic names.  
Save this document to docs/ECOSYSTEM\_STRATEGY.md or the project Wiki.

# ---

**The RatatuiRuby Ecosystem Strategy**

**The Constitution for the Native Ruby TUI Platform**  
Version: 1.0.0  
Status: Ratified  
Scope: Universal

## ---

**Introduction**

This document defines the architecture, philosophy, and roadmap of the RatatuiRuby ecosystem. It serves as the single source of truth for all stakeholders: architects, engineers, product owners, and contributors.  
We are building the "Rails of the Terminal." To achieve this, we rely on a layered architecture that creates a "Big Tent"—supporting both Functional and Object-Oriented paradigms on a single, high-performance Rust engine.

## ---

**Chapter 1: Vision & Philosophy**

### **What's in this Chapter**

* **The Goal:** Native Ruby performance, zero compromises.  
* **The Competition:** Friendly co-existence with CharmRuby.  
* **The Differentiator:** Rust FFI vs. Go Runtime.  
* **The "Big Tent":** Why we support two distinct architectures.

### **Chapter Summary**

We believe Ruby developers deserve world-class tools. We do not port foreign libraries. We build native bridges.  
Our engine, **RatatuiRuby**, wraps the industry-standard Rust crate ratatui. We use Rust because it has no runtime and no garbage collector. This prevents "runtime fighting" between the host language and the extension. It guarantees stability.  
We respect the work of **CharmRuby** (Bubble Tea for Ruby). It is an excellent port of Go libraries. However, our architecture differs fundamentally. CharmRuby bridges two managed runtimes (Ruby \+ Go). We bridge Ruby to bare metal (Rust). CharmRuby relies on string concatenation for views. We rely on a structured object tree.  
We adopt a "Big Tent" philosophy. We recognize that developers are divided between Functional Programming (Elm Architecture) and Object-Oriented Programming (Components). We do not force a choice. We provide two separate runtimes—**The Tea** and **The Kit**—that run on the same engine.

## ---

**Chapter 2: The Architecture**

### **What's in this Chapter**

* **The Stack:** Visualizing the layers.  
* **The Fork:** Where the path splits.  
* **The Unifier:** How Glimmer connects them.  
* **Naming Conventions:** Semantic names over version numbers.

### **Chapter Summary**

The ecosystem is organized into layers.

1. **The Engine (ratatui\_ruby):** The shared foundation. It handles rendering, layout, and events via Rust FFI. It is stateless and immediate-mode.  
2. **The Fork:** Here the user chooses their path.  
   * **Path A: The Tea (ratatui\_ruby-tea):** A functional, immutable runtime based on The Elm Architecture.  
   * **Path B: The Kit (ratatui-widgets):** An object-oriented, stateful component library.  
3. **The Syntax (glimmer-dsl-ratatui):** A declarative DSL that sits on top of *either* path to describe views.  
4. **The Framework (tuis-on-trails):** The "Rails" layer. It provides generators, database integration, and conventions for Path B.

We have deprecated numeric codes (Gem 1, 1.5, etc.). Refer to projects by their semantic role: Engine, Tea, Kit, Syntax, and Framework.

## ---

**Chapter 3: The Engine (ratatui\_ruby)**

### **What's in this Chapter**

* **Role:** The Stateless Renderer.  
* **API Design:** The Frame API (Proposal 3).  
* **Layout Lifecycle:** Calculate-then-Render.  
* **Event Loop:** Non-blocking polling.

### **Chapter Summary**

The Engine is the bedrock. It wraps Ratatui primitives (Block, Paragraph, Layout) but adds no state.  
We use the **Frame API** to bridge the gap between Ruby and Rust.

* **Implicit vs. Explicit:** We do not guess where widgets go. The user calculates layout constraints explicitly using Layout.split, then draws widgets into specific Rects using frame.render(widget, area).  
* **The Footgun Fix:** This API forces the user to separate layout calculation from rendering. This ensures that the geometry used for drawing is identical to the geometry used for hit-testing.

The Engine is responsible for the "Missing 4" primitives required by upper layers:

1. **Text Measurement:** Text.width(string) for auto-sizing.  
2. **Cursor Control:** frame.set\_cursor(x, y) for input fields.  
3. **Modifiers:** Reporting Shift and Ctrl keys.  
4. **Resize Events:** Reporting terminal dimension changes.

## ---

**Chapter 4: Path A \- The Tea (ratatui\_ruby-tea)**

### **What's in this Chapter**

* **Target Audience:** Tool builders, functional programmers.  
* **Architecture:** Model-View-Update (The Elm Architecture).  
* **Design Pattern:** "Jujube Redux" (Just Ruby).  
* **Concurrency:** Sync Logic, Async Work.

### **Chapter Summary**

**The Tea** is our implementation of The Elm Architecture. It is designed for strict correctness and data-flow purity.  
We adhere to the **"Just Ruby"** design pattern. We reject complex class hierarchies.

* **Model:** A frozen Data object.  
* **Update:** A Proc or Lambda. (Msg, Model) \-\> \[Model, Cmd\].  
* **View:** A Proc or Lambda. (Model) \-\> Tree.  
* **Cmd:** A Proc. () \-\> Msg.

We enforce **"Sync Logic, Async Work."** The Update function runs on the main thread and must never block. Side effects (HTTP, Shell) are encapsulated in Cmd procs, which the runtime executes on a background thread pool.  
We are **Ractor-Ready.** The runtime inspects all Messages in debug mode. If a Message captures mutable state, the runtime raises an error. This prepares users for Ruby 4.0 Ractors without breaking compatibility with Ruby 3.x Threads.

## ---

**Chapter 5: Path B \- The Kit (ratatui-widgets)**

### **What's in this Chapter**

* **Target Audience:** Enterprise developers, Dashboard builders.  
* **Architecture:** Retained-Mode Components.  
* **Lifecycle:** The Component Bridge.  
* **Focus Management:** The internal state machine.

### **Chapter Summary**

**The Kit** is our Object-Oriented solution. It bridges the gap between the stateless Engine and stateful applications.  
It introduces the Component class.

* **State:** Components persist in memory (e.g., @is\_focused, @input\_text).  
* **View Generation:** Every frame, the Kit walks the component tree. Each component’s view method returns a transient Engine struct.  
* **Events:** The Kit implements a **Focus Manager**. It routes keyboard events to the focused component and mouse events to the component at the clicked coordinates.

This layer handles the math that the Engine ignores. It uses the Engine's Text.width to calculate layout constraints and the Engine's Layout.split to perform hit testing.

## ---

**Chapter 6: The Syntax (glimmer-dsl-ratatui)**

### **What's in this Chapter**

* **Role:** The Unifier.  
* **Declarative UI:** Removing boilerplate.  
* **Data Binding:** Linking Model to View.  
* **Compatibility:** Working with Tea and Kit.

### **Chapter Summary**

**The Syntax** layer provides the Glimmer DSL. It allows developers to describe their UI structure visually, using nested blocks, rather than manually instantiating classes.  
It serves both paths:

* **For The Tea:** It provides a clean way to generate the View Tree from the Model. It acts as a template engine.  
* **For The Kit:** It provides bi-directional data binding (value \<= \[model, :name\]). It auto-wires event listeners (on\_selected { ... }).

This layer is optional but recommended. Users can always write raw Ruby code if they prefer explicit control.

## ---

**Chapter 7: The Framework (tuis-on-trails)**

### **What's in this Chapter**

* **Role:** The "Rails" experience.  
* **Structure:** MVC (Model-View-Component).  
* **Generators:** trails generate component.  
* **Integration:** ActiveRecord, Zeitwerk, Bundler.

### **Chapter Summary**

**The Framework** is the final layer. It is an opinionated wrapper around **The Kit** (Path B).  
It solves the "Blank Page" problem.

* It provides a standard directory structure (app/models, app/views, app/components).  
* It integrates the application loop with a database (ActiveRecord).  
* It manages configuration and environments.

**Trails** is strictly for the Object-Oriented path. The functional path (The Tea) is self-contained and does not require a heavy framework.

## ---

**Chapter 8: Contribution & Governance**

### **What's in this Chapter**

* **Development:** Rust/Ruby boundaries.  
* **Testing:** RSpec and Minitest.  
* **Documentation:** The Wiki and RDoc.  
* **Values:** Performance, Ergonomics, Kindness.

### **Chapter Summary**

We are stewards of the Ruby TUI ecosystem.

* **We value Performance:** If it slows down the loop, it doesn't go in.  
* **We value Ergonomics:** If the API feels clunky, rewrite it.  
* **We value Kindness:** We treat competitors as colleagues and users as partners.

Contributors working on **The Engine** must know Rust. Contributors working on upper layers need only know Ruby. All features must be accompanied by an interactive example in examples/.  
We adhere to Semantic Versioning. We break APIs only when necessary for correctness, and always with a deprecation warning.