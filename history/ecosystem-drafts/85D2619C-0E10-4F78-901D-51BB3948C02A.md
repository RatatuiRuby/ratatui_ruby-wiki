<!--
  SPDX-FileCopyrightText: 2026 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

Here is the consolidated **Ecosystem Strategy & Architecture Record**.  
This document merges the **Frame-Based Rendering (Proposal 3\)** implementation details, the **Gem 1.25 "Jujube Redux" Specification**, and the **"Big Tent" Strategy** into a single source of truth.  
It is written in the requested style: clear, direct, and dense. It serves as the constitution for the project's future.

# ---

**Ecosystem Strategy & Architecture Record**

Document ID: ESA-2025-001  
Version: 2.0 (The "Big Tent" Constitution)  
Status: Ratified  
Scope: Gems 1.0 through 3.0

## ---

**Chapter 1: The Executive Vision**

**The "Big Tent" Strategy**

### **In This Chapter**

* **The Core Philosophy:** Why we reject the "One True Way" of building UI.  
* **The Forked Path:** Defining the split between **Path A (Functional)** and **Path B (Object-Oriented)**.  
* **The Ecosystem Topology:** Naming conventions, require paths, and dependency graphs for all five gems.  
* **The User Personas:** Mapping the "Junior," "Frontend Dev," "Polyglot," and "Omakase Rubyist" to their respective stacks.

### **Chapter Summary**

We are not building a library. We are building an ecosystem.  
Most UI frameworks force a choice: functional purity or object-oriented pragmatism. We choose both. We recognize that a CLI tool has different architectural needs than a multi-window dashboard. Therefore, we have adopted the **Forked Path Strategy**.  
At the base lies **Layer 1 (The Engine)**. It is a shared, unopinionated, high-performance Rust renderer. It does not know what a "Button" is. It does not know what "State" is.  
Above Layer 1, the path splits.  
**Path A** is for the functional programmer. It uses **Gem 1.25 (ratatui-tea)**. It implements The Elm Architecture. State is a single immutable value. Updates are pure functions. Side effects are managed commands. This path optimizes for correctness, traceability, and simple tools.  
**Path B** is for the application architect. It uses **Gem 1.5 (ratatui-widgets)**. It implements a retained-mode Component system. State is distributed across objects. Updates are method calls. This path optimizes for encapsulation, large-scale team development, and "Rails-like" structure.  
Both paths eventually converge under **Layer 3 (glimmer-dsl-ratatui)**, which provides a unified declarative syntax for generating the UI trees for either architecture.  
We do not force the developer to adapt to the framework. We adapt the framework to the developer's problem.

## ---

**Chapter 2: Layer 1 \- The Engine**

**ratatui\_ruby (v1.0.0+)**

### **In This Chapter**

* **Architecture:** The specific boundaries of the Rust FFI and the magnus extension.  
* **The Frame API (Proposal 3):** Why we abandoned implicit tree rendering for the explicit draw { |frame| ... } block.  
* **The "Calculate Once" Pattern:** Solving the hit-testing footgun by separating layout calculation from rendering logic.  
* **Missing Primitives:** The P0 requirements for Text Measurement, Cursor Positioning, and Event Modifiers.  
* **Thread Safety:** The strict enforcement of Main Thread execution for all rendering operations.

### **Chapter Summary**

The Engine is the metal. It must be fast, stable, and theoretically pure.  
In v1.0.0, we made a decisive architectural pivot: we adopted **Frame-Based Rendering**. Previously, users passed a declarative tree to the engine. This hid the layout logic inside Rust, making it impossible for the Ruby layer to know where widgets were drawn. This broke hit-testing.  
We replaced this with the Frame API. Now, the user provides a block. The engine yields a Frame. The user explicitly calculates layout using Layout.split and explicitly renders widgets into those areas using frame.render.  
This restores the **Single Source of Truth**. The Rect calculated for layout is the exact same object used for rendering and for mouse event detection. There is no duplication. There is no ambiguity.  
This layer remains strictly **Immediate Mode**. It retains no state between frames. It constructs a UI description, renders it to the buffer, and destroys it. It provides the raw capability—Text Width, Cursor Control, Resize Events—that upper layers use to build abstractions.

## ---

**Chapter 3: Layer 2A \- The Functional Runtime**

**ratatui-tea (Gem 1.25)**

### **In This Chapter**

* **Specification:** The "Jujube Redux" spec for a Ruby-native Elm Architecture.  
* **Concurrency Model:** "Sync Logic, Async Work." The rigorous separation of the Main Thread (Update/View) from the Worker Pool (Commands).  
* **The Trojan Horse:** Enforcing Ractor-compatibility (Deep Freezing) in v1.0 to prepare for a v2.0 Ractor migration.  
* **API Design:** Rejecting inheritance in favor of Callable Objects (Proc, Lambda).  
* **Fractal Architecture:** How to compose models and update functions to prevent the "God Reducer" anti-pattern.

### **Chapter Summary**

Path A is the path of data.  
ratatui-tea is a runtime for pure state machines. It adheres to a strict contract: **Data In, Data Out.** The user provides an initial Model, an Update function, and a View function. The runtime manages the loop.  
We have rejected the "Base Class" inheritance model common in Ruby. Instead, we use **Callable Objects**. A Command is not a class; it is a Proc. An Update handler is not a method override; it is a Lambda passed to the constructor. This reduces API surface area and encourages composition over inheritance.  
Crucially, this layer acts as a **Trojan Horse** for modern Ruby concurrency. While it runs on Threads today, it enforces strict immutability on all Models and Messages. In Debug mode, it checks Ractor.shareable?. If a user passes a mutable object, the runtime crashes. This ensures that when Ruby 4.0/5.0 Ractors mature, this library can swap its backend without breaking a single line of user code.  
This is the "Just Ruby" solution. No DSLs. No magic. Just pure functions transforming immutable state.

## ---

**Chapter 4: Layer 2B \- The Component Kit**

**ratatui-widgets (Gem 1.5)**

### **In This Chapter**

* **Philosophy:** Bridging the gap between Immediate Mode rendering and Retained Mode application logic.  
* **The Component Lifecycle:** mount, update, view, unmount.  
* **The "View Generation" Bridge:** How stateful components generate ephemeral Layer 1 structures for the Frame API.  
* **Focus Management:** The FocusManager singleton, tab cycles, and key routing.  
* **Hit Testing:** Leveraging Layer 1's Frame to route mouse events to specific Component instances.

### **Chapter Summary**

Path B is the path of objects.  
While Layer 1 forgets everything every frame, ratatui-widgets remembers. It introduces the **Component**: a persistent Ruby object that holds state (@focused, @text\_value) and logic.  
The core innovation here is the reconciliation with the Immediate Mode engine. A Component does not draw itself directly. Instead, it implements a view method that returns Layer 1 data structures. Every frame, the application walks the Component tree, generates a fresh Layer 1 render tree, and passes it to the Engine.  
This layer handles the complexity that raw Ratatui ignores. It knows which button is focused. It knows that *Shift+Tab* moves backwards. It knows that when a user clicks at (15, 4), that coordinate belongs to the SubmitButton instance.  
This is the layer for the "Enterprise" developer. It provides encapsulation, namespace isolation, and familiar Object-Oriented patterns.

## ---

**Chapter 5: Layer 3 \- The Syntax**

**glimmer-dsl-ratatui (Gem 2.0)**

### **In This Chapter**

* **Role:** The DSL as a "Skin," not a "Brain."  
* **Adaptation:** How the same DSL syntax generates different outputs for Path A (Hash/Tree) and Path B (Component Instantiation).  
* **Data Binding:** Unidirectional binding for TEA; Bidirectional binding for Components.  
* **The "Dead End" Rule:** Why users must choose their path (TEA vs. Components) at project creation and cannot mix them arbitrarily.

### **Chapter Summary**

Glimmer is the unifying language of the ecosystem.  
It allows developers to describe their UI structure declaratively, rather than imperatively constructing objects. However, Glimmer is structurally agnostic. It does not enforce an architecture; it describes one.  
When used with **Path A (TEA)**, the DSL generates a static tree of Layer 1 structs. It is purely a view templating language. It does not handle events; it simply maps the current Model to a visual hierarchy.  
When used with **Path B (Components)**, the DSL becomes an object factory. It instantiates Component classes, wires up event listeners (on\_click), and binds properties (text \<= \[model, :name\]).  
We explicitly enforce the **Dead End Rule**: A project is either a TEA project or a Component project. The DSL adapts to the context, but the contexts do not mix. This prevents architectural incoherence.

## ---

**Chapter 6: Competitive Strategy**

**Vs. The World**

### **In This Chapter**

* **Vs. CharmRuby:** The architectural cost of bridging Go and Ruby runtimes vs. the native Rust extension.  
* **Vs. Native Rust:** The productivity of Ruby combined with the performance of Rust (best of both worlds).  
* **Vs. Native Go:** The ecosystem advantage (Rails, Active Record) vs. the simplicity of Go.

### **Chapter Summary**

We operate in a competitive landscape defined by **CharmRuby**.  
CharmRuby is a technical marvel that ports Go libraries to Ruby. However, it suffers from **Runtime Fighting**. Running the Go Garbage Collector alongside the Ruby Garbage Collector introduces overhead and concurrency "quirks."  
**RatatuiRuby** wins on architecture. Rust has no runtime. It has no garbage collector. It yields completely to Ruby. When a user runs RatatuiRuby, they get the raw, unadulterated speed of compiled Rust with the stability of a single-threaded Ruby process.  
We also win on flexibility. CharmRuby locks users into the Elm Architecture (Bubble Tea). We offer the "Big Tent." If a user likes Elm, ratatui-tea gives them a native, faster version. If a user likes Objects, ratatui-widgets gives them a capability CharmRuby does not possess.  
We do not denigrate our competitors. We simply out-architect them.

## ---

**Chapter 7: The Roadmap**

**The "Onion Peel" Execution**

### **In This Chapter**

* **Phase 1: Unblocking (Current):** poll\_event timeout, Resize events, Text Width.  
* **Phase 2: The Quick Win:** Shipping ratatui-tea (Gem 1.25) to capture the functional market immediately.  
* **Phase 3: The Heavy Lift:** Building ratatui-widgets (Gem 1.5) to enable the component model.  
* **Phase 4: The Syntax:** Releasing glimmer-dsl-ratatui (Gem 2.0) only after the component model is mature.  
* **Phase 5: The Framework:** ratatui-trails (Gem 3.0).

### **Chapter Summary**

Order matters.  
We cannot build the DSL (Layer 3\) before we build the Component Kit (Layer 2B), or the DSL will have nothing to instantiate. We cannot build the Component Kit before the Engine (Layer 1\) exposes the primitives (Cursor, Text Width) needed to measure layouts.  
Therefore, we execute in strict serial order: **The Onion Peel.**  
We finish the Engine first. We ship the lightweight TEA runtime second, securing a quick strategic victory. We then invest the heavy engineering time into the Component Kit. Only when the foundation is solid do we apply the sugar of Glimmer.  
We do not build vaporware. We build layers of dependencies, each fully functional before the next begins. This ensures that at any point, the ecosystem is stable, usable, and production-ready.