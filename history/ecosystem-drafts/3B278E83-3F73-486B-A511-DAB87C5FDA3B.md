<!--
  SPDX-FileCopyrightText: 2026 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

To: The CEO of RatatuiRuby  
From: The Council of Architects & The Technical Writer  
Date: January 2, 2026  
Subject: Canonical Architecture Document: ratatui\_ruby-tea (Gem 1.25)  
After the "Pizza Summit" and subsequent rigorous debate within the Council of Architects, we have reached **unanimous consensus**.  
We have successfully merged the CTO's demand for radical simplicity ("Just use Procs") with the Architect's requirement for safety ("Trojan Horse"). The resulting architecture is leaner, faster, and more Ruby-native than any previous iteration.  
This document is the definitive source of truth.

# ---

**Canonical Architecture: ratatui\_ruby-tea**

Version: 1.0.0 (The "Just Ruby" Specification)  
Layer: 2A (The Functional Path)  
Codename: Jujube Redux

## **1\. Executive Vision & Ecosystem Position**

ratatui\_ruby-tea is a functional runtime for Terminal User Interfaces. It sits directly atop the ratatui\_ruby engine.  
In the "Big Tent" ecosystem, this gem represents **Path A: The Functional Path**.

* **Philosophy:** "Data In, Data Out."  
* **Target:** CLI tools, developer utilities, and high-control state machines.  
* **Differentiation:** Unlike **Path B (Components)**, which manages state in objects, **Path A** manages state in a single immutable data structure.

The "Just Ruby" Pivot:  
We reject complex class hierarchies for control flow. We rely on Ruby's native data structures.

* **Commands** are just Procs.  
* **Batches** are just Arrays.  
* **Subscriptions** are just Loops.

## **2\. Core Philosophy**

### **2.1. "Sync Logic, Async Work"**

To guarantee a 60 FPS UI on the Ruby Main Thread:

* **The Main Thread:** Owns the Update and View functions. These must be pure and fast. They calculate the *next* state; they never *wait* for I/O.  
* **The Worker Pool:** Owns Cmd execution. All side effects (HTTP, Timers, Shell) run here.

### **2.2. The "Trojan Horse" (Ractor Readiness)**

We build for Ruby 4.0 Ractors but ship on Threads.

* **Constraint:** The Runtime enforces that all **Models** and **Messages** are Ractor-shareable (Deeply Frozen).  
* **Safety:** In Debug Mode, we run Ractor.shareable?(msg). If it fails, we inspect the object graph and print a specific error: *"Your message captured a mutable variable (@logger). Please pass data only."*

## **3\. System Architecture**

### **3.1. The "Fast Loop" Algorithm**

The runtime is managed by RatatuiRuby::TEA::Program (internal) but exposed via RatatuiRuby::TEA.run (public).

Ruby

\# Pseudo-code of the Canonical Loop  
loop do  
  \# 1\. RENDER (Main Thread)  
  \# Pure transform: Model \-\> Widget Tree  
  ui\_tree \= view.call(model)  
  RatatuiRuby.draw(ui\_tree)

  \# 2\. POLL (Main Thread)  
  \# Blocks for max 16ms (60 FPS).  
  \# Priority: Worker Queue \> User Input.  
  msg \= cmd\_queue.pop(non\_blocking: true)   
  unless msg  
    \# P0 Requirement: ratatui\_ruby must support timeout  
    event \= RatatuiRuby.poll\_event(timeout: 0.016)   
    msg \= map\_event(event) if event  
  end

  \# 3\. UPDATE (Main Thread)  
  if msg  
    \# The user function returns Model OR \[Model, Cmd\] OR \[Model, Cmd, Cmd\]  
    result \= update.call(msg, model)  
    model, \*cmds \= normalize\_result(result) 

    \# 4\. DISPATCH (Worker Thread)  
    \# Fire and forget.  
    cmds.flatten.each do |proc|  
      Thread.new {  
        result\_msg \= proc.call  
        cmd\_queue.push(result\_msg) if result\_msg  
      }  
    end  
  end  
end

## **4\. API Design: Radical Simplicity**

We use **Callable Objects** for everything. No base classes.

### **4.1. The User Interface**

Ruby

RatatuiRuby::TEA.run(  
  model: InitialState.new,  
  update: \-\>(msg, model) { ... },  
  view: \-\>(model) { ... }  
)

### **4.2. Commands (Cmd)**

A Command is simply a Proc that performs work and returns a Msg.

* **Old Way:** Cmd::Exec.new("ls") (Class)  
* **New Way:** \-\> { ls } (Proc)

The Factory Module:  
To satisfy "Batteries Included," we ship RatatuiRuby::TEA::Cmd as a module of factory methods that return Procs.

Ruby

module RatatuiRuby::TEA::Cmd  
  \# Returns a Proc that runs the shell command  
  def self.exec(command, on\_exit: nil)  
    \-\> {  
      out, status \= Open3.capture2(command)  
      on\_exit ? on\_exit.call(out, status) : nil  
    }  
  end

  \# Returns a Proc that sleeps  
  def self.wait(seconds, msg)  
    \-\> { sleep(seconds); msg }  
  end  
end

### **4.3. Batches (Arrays)**

We do not need a Batch class. Update can return an Array of commands.

* **Signature:** \[Model, Cmd, Cmd\] or \[Model, \[Cmd, Cmd\]\]. The runtime flattens it.

### **4.4. Subscriptions (Recursive Commands)**

We do not need a Subscription manager. We use **Recursive Commands**.

* **Pattern:** A Command performs work (e.g., sleep 1s), returns a Msg, and the Update handler for that message returns *the same Command again*.  
* **Benefit:** Zero extra API surface. It uses the existing thread pool naturally.

## **5\. Scalability: Fractal Architecture**

We support composition via Cmd.map.

### **5.1. The Mechanism**

Since Cmd is just a Proc, we provide a helper to wrap it.

Ruby

module RatatuiRuby::TEA::Cmd  
  def self.map(inner\_cmd, \&mapper)  
    \-\> {  
      result\_msg \= inner\_cmd.call  
      mapper.call(result\_msg) \# Wrap child msg in parent msg  
    }  
  end  
end

### **5.2. The Documentation**

We will document the **"Component Pattern"**:

1. Define a Sub-Module (Header).  
2. Define Header::Model, Header.update, Header.view.  
3. In Main Update:  
   Ruby  
   new\_header, cmd \= Header.update(msg, model.header)  
   mapped\_cmd \= TEA::Cmd.map(cmd) { |m| HeaderMsg.new(m) }  
   \[model.with(header: new\_header), mapped\_cmd\]

## **6\. Interoperability & Forward Compatibility**

### **6.1. The Glimmer Protocol**

To enable the future glimmer-dsl-ratatui to work with TEA, we reserve a protocol message now.

* **Message:** RatatuiRuby::TEA::Msg::FieldUpdated \= Data.define(:field, :value)  
* **Behavior:** Future DSLs will dispatch this message when a user types in a field. The user handles it in Update to modify their immutable model.

## **7\. Developer Experience (DX)**

We support two "Flavors" to capture the full market.

### **Flavor A: The "Script" (Functional)**

*Target: Quick tools, prototypes.*

Ruby

RatatuiRuby::TEA.run(  
  model: 0,  
  update: \-\>(msg, model) {  
    case msg  
    when :inc then model \+ 1 \# Implied nil cmd  
    when :quit then \[model, RatatuiRuby::TEA::Cmd.quit\]  
    end  
  },  
  view: \-\>(model) { RatatuiRuby::Paragraph.new(text: model.to\_s) }  
)

### **Flavor B: The "Service" (Structured)**

*Target: Enterprise tools.*

Ruby

class MainController  
  def call(msg, model)  
    \# Structured logic using service objects  
  end  
end

RatatuiRuby::TEA.run(  
  model: State.new,  
  update: MainController.new,  
  view: MainView.new  
)

## **8\. Implementation Checklist**

1. **Blocker (Gem 1):** Ship poll\_event(timeout: Float). **(P0)**  
2. **Runtime:** Implement TEA.run loop.  
3. **Normalization:** Ensure runtime accepts Model, \[Model, Cmd\], or \[Model, Array\<Cmd\>\].  
4. **Batteries:** Implement Cmd.exec, Cmd.wait, Cmd.quit (factory methods).  
5. **Safety:** Implement Ractor.shareable? check in debug mode.  
6. **Composition:** Implement Cmd.map.  
7. **Docs:** Write the "Recipe Book" for HTTP (Net::HTTP) and Shell execution.

---

Signed:  
The Internal Architect (Chairman)  
The Technical Writer (Editor)  
Approved by The Council of Architects