<!--
  SPDX-FileCopyrightText: 2026 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

Here is the comprehensive Ecosystem Strategy Document. It integrates Proposal 3 (Frame-based Engine), the Gem 1.25 Specification (Jujube Redux), and the Component/Glimmer roadmap into a single constitutional text.

# ---

**THE RATATUI RUBY ECOSYSTEM: STRATEGY & ARCHITECTURE**

Version 2.0 (The "Big Tent" Constitution)  
Status: Ratified

## **INTRODUCTION**

### **What’s in this Introduction**

* The mission of RatatuiRuby.  
* The definition of the "Big Tent" strategy.  
* The intended audience for this document.

### **Summary**

We are building the definitive Terminal User Interface (TUI) ecosystem for Ruby. Our mission is simple. We want to bring the power of Rust’s Ratatui engine to Ruby developers without the pain of Rust’s strictness. We are not building a wrapper. We are building a native runtime.  
We believe in the "Big Tent." We do not force developers to choose a single coding style. We support functional programmers who love the Elm Architecture. We support object-oriented programmers who love Rails and Glimmer. Both paths lead to the same destination: high-performance, beautiful terminal applications. Both paths run on the same engine.  
This document is our constitution. It explains how the pieces fit. It explains why we made specific technical choices. It guides future architects, product managers, and contributors. Read it to understand where we are going. Read it to understand why we aren't using Go. Read it to build the future of the Ruby terminal.

## ---

**CHAPTER 1: THE PHILOSOPHY**

### **What’s in this Chapter**

* Why we chose Rust over Go or C.  
* The value of "Native" over "Ported."  
* The "Forked Path" architectural decision.  
* The rejection of "Lowest Common Denominator."

### **Chapter Summary**

We chose Rust for a reason. Rust has no runtime. It has no garbage collector. When you call RatatuiRuby, you run pure machine code. It yields completely to Ruby. This prevents the "Runtime War" seen in other libraries, where a Go garbage collector fights a Ruby garbage collector for resources. Our engine is silent. It is fast. It is stable.  
We believe in native solutions. We do not bridge foreign libraries. We build native extensions. This ensures thread safety. It ensures compatibility with Ruby's tooling, like debuggers and profilers.  
We embrace the "Forked Path." We acknowledge that the Functional and Object-Oriented paradigms are mutually exclusive at the application layer. We do not try to mix them. Instead, we provide two distinct, optimized paths on top of a shared engine. You choose your path at the start. You do not look back. This allows us to optimize each path fully without compromise.

## ---

**CHAPTER 2: LAYER 1 — THE ENGINE (ratatui\_ruby)**

### **What’s in this Chapter**

* The role of the Engine as a stateless renderer.  
* **Decision Record:** Adoption of Proposal 3 (The Frame API).  
* The dual-mode draw method.  
* The "Missing 4" Primitives (Text Width, Cursor, Modifiers, Resize).  
* Blocking vs. Non-blocking event polling.

### **Chapter Summary**

The Engine is the foundation. It knows nothing about buttons, state, or focus. It only knows how to draw. It is an "Immediate Mode" renderer. It draws the entire screen every frame. It forgets everything immediately after.  
We adopted the **Frame API** (Proposal 3). This aligns us with the Rust implementation of Ratatui. Users gain explicit control. They ask the engine for a Frame. They split that frame into layouts. They render widgets into specific Rects. This solves the "Layout Footgun." You calculate layout once. You use the results for rendering. You use the same results for hit testing.  
The Engine supports two modes.

1. **Imperative Mode:** draw { |frame| ... }. This gives total control. It is the foundation for Layer 2B (Components).  
2. **Declarative Mode:** draw(tree). This accepts a pre-built tree of data. It is the foundation for Layer 2A (TEA).

We added critical primitives. Text.width allows components to measure themselves. set\_cursor allows text inputs to blink. poll\_event(timeout: Float) allows the loop to breathe. These are not features. They are physics. They are the laws of the universe that upper layers rely on.

## ---

**CHAPTER 3: THE FORK IN THE ROAD**

### **What’s in this Chapter**

* The architectural split between Layer 2A and Layer 2B.  
* How to choose a path.  
* The mutual exclusivity of the layers.  
* The shared dependency on Layer 1\.

### **Chapter Summary**

After Layer 1, the ecosystem splits. You cannot mix these paths.  
**Path A (Functional)** is for tools. It uses The Elm Architecture (TEA). State is a single immutable object. Updates are pure functions. Side effects are managed commands. This path is rigorous. It is safe. It is perfect for complex state machines and CLIs.  
**Path B (Object-Oriented)** is for platforms. It uses Retained Mode Components. State is distributed across objects. Updates are method calls. Side effects are immediate. This path is expressive. It is familiar. It is perfect for dashboards, data-entry systems, and "Rails-like" applications.  
Both paths are first-class citizens. We maintain both. We optimize both. But we do not bridge them. A TEA app cannot mount a Component. A Component cannot run a TEA loop. Choose your weapon.

## ---

**CHAPTER 4: LAYER 2A — THE FUNCTIONAL PATH (ratatui\_ruby-tea)**

### **What’s in this Chapter**

* Specification: "Jujube Redux."  
* The "Just Ruby" philosophy (Procs over Classes).  
* The "Sync Logic, Async Work" concurrency model.  
* **The Trojan Horse:** Enforcing Ractor safety today for Ruby 4.0 tomorrow.  
* Fractal Architecture for scaling.

### **Chapter Summary**

This is the path of data. We reject complex class hierarchies. An "App" is not a class. It is a set of callable objects: update, view, and init. Commands are Procs. Batches are Arrays. We use the language as it is.  
We enforce a strict concurrency model. Logic runs on the main thread. Work runs on background threads. The runtime manages this handoff. To prepare for the future, we enforce **Ractor Safety** now. The runtime checks that every Message and Model is deeply frozen. If you pass mutable state, we crash. We do this to save you from race conditions. We do this so that when Ruby 4.0 arrives, your code is ready.  
We solve the "Monolith Problem" with Fractal Architecture. We teach users to slice their state. A parent Model holds child Models. A parent Update calls child Updates. We provide Cmd.map to wrap child messages. This allows apps to grow infinitely without becoming unmanageable.

## ---

**CHAPTER 5: LAYER 2B — THE OBJECT PATH (ratatui\_ruby-components)**

### **What’s in this Chapter**

* The Retained Mode Component Model.  
* The Component base class lifecycle.  
* The View Generation Phase (Reconciliation).  
* Hit Testing using the Frame API.  
* The Focus Manager.

### **Chapter Summary**

This is the path of objects. A Component is a Ruby object that persists in memory. It holds its own state. It knows if it is focused. It knows if it is hovered.  
The render cycle is distinct here. A component does not draw directly to the screen. It generates a "View Tree"—a transient structure of Layer 1 data objects. The system takes this tree and hands it to the Engine. This is "Reconciliation." It bridges the gap between our stateful objects and the stateless Rust engine.  
Hit testing is handled by the Component. Because we use the Frame API in Layer 1, the Component knows exactly where it drew itself. It stores its Rect. When a mouse event arrives, the Focus Manager checks these Rects. It routes the click to the correct component. The developer writes on\_click. The system handles the geometry.

## ---

**CHAPTER 6: LAYER 3 — THE SYNTAX (glimmer-dsl-ratatui)**

### **What’s in this Chapter**

* The role of Glimmer as a syntax adapter.  
* Support for Path A (TEA) Views.  
* Support for Path B (Component) Composition.  
* Data Binding rules (Unidirectional vs. Bidirectional).

### **Chapter Summary**

Glimmer is not a framework. It is a skin. It makes the code look like the UI. It replaces verbose object instantiation with clean, nested blocks.  
For **Path A (TEA)**, Glimmer is a templating language. It builds the View Tree from the Model. It supports **unidirectional** binding only. The UI reflects the state. It never changes it directly.  
For **Path B (Components)**, Glimmer is a composition tool. It builds the hierarchy of components. It supports **bidirectional** binding. value \<= \[model, :name\] ties the UI directly to the object. Changes flow both ways. This is the "Magic" that Rails developers expect.

## ---

**CHAPTER 7: LAYER 4 — THE FRAMEWORK (tuis\_on\_trails)**

### **What’s in this Chapter**

* The "Rails for TUI" vision.  
* Generators and Scaffolding.  
* Integration with Active Record.  
* The Application Lifecycle.

### **Chapter Summary**

This is the destination. TUIsonTrails is the framework that ties it all together. It is opinionated. It assumes you want a database. It assumes you want structure.  
It provides trails new. It generates the directory structure. It configures the database. It wires up the event loop. It creates the "ApplicationComponent" or the "MainReducer." You do not write boilerplate. You write logic.  
It bridges the gap between the UI and the data. It provides the glue that connects an Active Record model to a generic Table component. It manages the lifecycle of the application, from boot to shutdown. It is the professional environment for professional applications.

## ---

**CHAPTER 8: COMPETITIVE STRATEGY**

### **What’s in this Chapter**

* Positioning against CharmRuby (Go).  
* Positioning against Native Rust.  
* The "No Compromise" value proposition.

### **Chapter Summary**

We respect our competitors. We do not fear them.  
**CharmRuby** is excellent. It ports Go libraries to Ruby. But it carries the weight of the Go runtime. We offer a native alternative. Our "Functional Path" (Layer 2A) offers the same developer experience as Bubble Tea (TEA), but with the performance of Rust and the safety of native extensions. We win on architecture.  
**Native Rust** is powerful. But it is slow to write. We offer the speed of development that only Ruby can provide. We give you the Rust engine without the Rust compiler. We win on ergonomics.  
We define the market. We are the only ecosystem that offers both Functional and Object-Oriented paths on a single, high-performance engine. We are the "Big Tent." We welcome everyone.

## ---

**CHAPTER 9: CONTRIBUTION & GOVERNANCE**

### **What’s in this Chapter**

* Ractor Safety requirements for all code.  
* Documentation standards (Alexandrian Form).  
* The "Trojan Horse" enforcement policy.  
* How to propose changes.

### **Chapter Summary**

We hold ourselves to a high standard. We write for the future.  
Every line of code must be Ractor-safe. We do not use global mutable state. We freeze our constants. We design for parallelism, even if we run on threads today.  
We document everything. We use the Alexandrian Form: Context, Problem, Solution. We explain "Why," not just "How." We write simply. We use short sentences. We assume the reader is intelligent but busy.  
We are strict about the architecture. We do not blur the lines between Layer 2A and Layer 2B. We do not leak abstractions from Layer 1\. We protect the integrity of the "Forked Path." We build for the next decade of Ruby.