<!--
  SPDX-FileCopyrightText: 2025 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

Here is the comprehensive Ecosystem Strategy document for the Wiki. It synthesizes all approved proposals (Proposal 3, Gem 1.25/Jujube Redux) into a single, canonical source of truth.

# ---

**The RatatuiRuby Ecosystem Strategy**

Version: 2.0 (The "Big Tent" Constitution)  
Date: December 31, 2025  
Status: Canonical  
This document defines the architecture, philosophy, and future roadmap of the RatatuiRuby project. It is written for architects, contributors, and leadership. It serves as the primary reference for understanding how our distinct libraries form a cohesive ecosystem.

## ---

**Chapter 1: The "Big Tent" Vision**

### **What's in this Chapter**

* The core philosophy of the ecosystem.  
* The "Forked Path" architecture.  
* The definitions of our five core libraries.

### **Context**

Terminal User Interfaces (TUIs) generally force a choice: Object-Oriented (like Qt/Swing) or Functional (like Elm). Rubyists are divided. Some prefer the "Omakase" Object-Oriented nature of Rails. Others prefer the purity of functional pipelines.

### **Problem**

If we build only an Object-Oriented framework, we alienate functional programmers. If we build only a Functional framework, we alienate classic Rubyists. Choosing one paradigm limits our market share.

### **Solution**

We build a **Universal Runtime**. We provide a single high-performance engine (Layer 1\) that powers two mutually exclusive application architectures (Layer 2).

* **Path A (Functional):** The Elm Architecture. Data in, data out.  
* **Path B (Object-Oriented):** Component-based. Objects with state.

Both paths run on the exact same Rust engine. Both paths can use the same Glimmer DSL syntax.

### **The Stack**

| Layer | Internal Name | Official Gem | Role |
| :---- | :---- | :---- | :---- |
| **1** | **The Engine** | ratatui\_ruby | **Renderer.** The Rust FFI wrapper. Stateless. |
| **2A** | **The Tea** | ratatui\_ruby-tea | **Functional Runtime.** The Elm Architecture (TEA). |
| **2B** | **The Kit** | ratatui-widgets | **Component Kit.** Stateful objects and focus management. |
| **3** | **The Syntax** | glimmer-dsl-ratatui | **DSL.** Declarative Ruby syntax for Views. |
| **4** | **The Frame** | tuis\_on\_trails | **Framework.** Generators, DB integration, App lifecycle. |

## ---

**Chapter 2: The Engine (Gem 1\)**

### **What's in this Chapter**

* The role of ratatui\_ruby.  
* The Frame-Based Rendering API (Proposal 3).  
* The "Missing 4" Primitives.

### **Context**

The Engine is the foundation. It must be unopinionated. It must not know what a "Button" is. It must not know what "Focus" is. Its only job is to provide a bridge to the Ratatui Rust library.

### **Problem**

Immediate-mode rendering is fast but dangerous. Users often calculate layout twice: once to draw, and once to check for mouse clicks. This duplication ("The Footgun") leads to bugs where the click target doesn't match the drawn widget.

### **Solution: The Frame API**

We adopt **Frame-Based Rendering** (Proposal 3). This aligns perfectly with the Rust ratatui crate.  
The Engine yields a Frame object to the draw block. The user calculates the layout *inside* the block. They explicitly tell the frame where to render widgets. This gives the user the calculated Rect objects immediately, which they can save for hit-testing in the next frame.

Ruby

\# The Canonical Pattern  
def render  
  RatatuiRuby.draw do |frame|  
    \# 1\. Calculate Layout ONCE  
    @sidebar\_rect, @main\_rect \= Layout.split(frame.area, ...)

    \# 2\. Render Explicitly  
    frame.render(sidebar\_widget, @sidebar\_rect)  
    frame.render(main\_widget, @main\_rect)  
  end  
end

### **The "Missing 4" Primitives**

To support the layers above it, the Engine must expose four critical low-level tools:

1. **Text Measurement:** Text.width("str"). Needed for auto-sizing components.  
2. **Cursor Control:** frame.set\_cursor(x, y). Needed for Text Inputs.  
3. **Event Modifiers:** Ctrl+C, Shift+Tab. Needed for navigation.  
4. **Resize Events:** poll\_event returns resize. Needed for responsive layouts.

### **Chapter Summary**

The Engine is a low-level, high-performance binding. It uses Frame-Based Rendering to give developers precise control over layout and rendering. It provides the raw materials (measurement, cursors, events) that upper layers use to build abstractions.

## ---

**Chapter 3: The Functional Path (Gem 1.25)**

### **What's in this Chapter**

* The "Just Ruby" Philosophy.  
* The "Sync Logic, Async Work" concurrency model.  
* The Trojan Horse strategy for Ractors.

### **Context**

Functional programmers want The Elm Architecture (TEA). They want a loop where Update(Msg, Model) \-\> (Model, Cmd).

### **Problem**

Most ports of TEA to Ruby use complex class inheritance (class MyApp \< Tea::App). This feels heavy. Ruby is dynamic; it doesn't need the ceremony of static languages like Go or Java.

### **Solution: "Jujube Redux"**

We implement TEA using **Callable Objects** only. No base classes. No inheritance.

* **Model:** Use Data classes or Integers.  
* **Update:** A Proc or Lambda.  
* **View:** A Proc or Lambda.  
* **Cmd:** A Proc that returns a Message.

### **Concurrency: Sync Logic, Async Work**

Ruby has a Global Interpreter Lock (GIL). To maintain 60 FPS, the main thread must never block.

* **Main Thread:** Runs Update and View. These must be pure and fast.  
* **Worker Pool:** Runs Cmds (Side effects). These handle HTTP, database, and timers.

### **The Trojan Horse (Ractors)**

We are building for Ruby 4.0's Ractors (true parallelism), but we ship today on Threads.

* **The Rule:** The Runtime enforces that all Messages and Models are **deeply frozen**.  
* **The Check:** In Debug mode, we call Ractor.shareable? on every Message. If it fails, we crash.  
* **The Result:** When we swap the engine to use Ractors in v2.0, user code will already be compatible.

### **Chapter Summary**

ratatui\_ruby-tea is the functional runtime. It favors composition over inheritance. It enforces strict immutability to prepare for a parallel future. It is optimized for CLI tools and developer utilities.

## ---

**Chapter 4: The Object Path (Gem 1.5)**

### **What's in this Chapter**

* The Component Model.  
* The generation of transient Render Trees.  
* Focus Management.

### **Context**

Enterprise developers and Rails engineers prefer Object-Oriented Programming. They think in terms of "Widgets" that have internal state (like @text in an input field).

### **Problem**

The Engine (Layer 1\) is stateless. It forgets everything after every frame. How do we build stateful buttons on a stateless engine?

### **Solution: The Component Kit**

We introduce ratatui-widgets. This layer introduces the Component class.

* **Retained Mode:** Components persist in memory.  
* **State:** Components hold their own state (@focused, @value).  
* **The Bridge:** Every frame, the Component generates a transient Layer 1 struct (a Block or Paragraph) representing its *current* state.

### **Hit Testing & Focus**

The Component Kit handles the "Math."

* **Focus Manager:** It maintains a list of focusable components. It routes keyboard events *only* to the active component.  
* **Hit Testing:** It uses the Frame API from Layer 1\. When a component renders, it records its area. When a mouse click arrives, the Kit routes the click to the component sitting at those coordinates.

### **Chapter Summary**

ratatui-widgets brings Retained Mode to the ecosystem. It allows developers to build complex dashboards using standard OOP patterns. It bridges the gap between the stateful application and the stateless renderer.

## ---

**Chapter 5: The Syntax (Gem 2\)**

### **What's in this Chapter**

* The role of Glimmer.  
* Adaptability to both paths.

### **Context**

Building UI trees manually (Layout.new(children: \[Block.new(...)\])) is verbose. It is hard to read.

### **Problem**

Rubyists expect elegance. They want a syntax that mirrors the visual hierarchy of the UI.

### **Solution: The Glimmer DSL**

We implement glimmer-dsl-ratatui. This provides a declarative syntax for creating UI trees.

Ruby

vertical\_layout {  
  block(title: "Sidebar") {  
    paragraph(text: "Menu Item 1")  
  }  
}

### **The Universal Adapter**

Because both Path A (TEA) and Path B (Components) ultimately rely on Layer 1 structs, the DSL works for **both**.

* **For TEA:** The view function returns a DSL-generated tree.  
* **For Components:** The view method returns a DSL-generated tree.

### **Chapter Summary**

The DSL is syntax sugar. It does not contain logic. It describes structure. It unifies the developer experience across both architectural paths.

## ---

**Chapter 6: The Strategy & Comparison**

### **What's in this Chapter**

* Why we win against CharmRuby.  
* Why we win against Rust/Go.

### **Vs. CharmRuby**

CharmRuby is an excellent port of Go libraries. It bridges Ruby and Go.  
The RatatuiRuby Advantage:

1. **Architecture:** We are Native. We use Rust extensions (no runtime overhead) instead of bridging to the Go runtime. We avoid the garbage-collector fighting inherent in Go-Ruby bridges.  
2. **Flexibility:** CharmRuby forces you into the Elm Architecture. RatatuiRuby gives you a choice. Use ratatui\_ruby-tea if you like Elm. Use ratatui-widgets if you prefer Objects.

### **Vs. Writing in Rust**

Rust is performant but rigid.  
The RatatuiRuby Advantage:  
We give you the performance of the Rust renderer (Ratatui) with the iteration speed of Ruby. You don't fight the borrow checker to move a button. You get the best of both worlds.

### **Vs. Writing in Go**

Go is pragmatic but verbose.  
The RatatuiRuby Advantage:  
We offer the Ruby Ecosystem. You can use Active Record. You can use RSpec. You can write expressive DSLs. You don't have to leave the language you love to build world-class tools.

### **Chapter Summary**

We position RatatuiRuby not just as a library, but as a **Platform**. We offer the performance of Rust, the flexibility of Ruby, and the freedom to choose your architecture.