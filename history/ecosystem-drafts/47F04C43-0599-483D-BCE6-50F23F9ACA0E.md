<!--
  SPDX-FileCopyrightText: 2026 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

Here is the definitive **Ecosystem Strategy & Architecture Design Record**.  
This document serves as the constitution for the RatatuiRuby project. It synthesizes the technical foundations of v1.0.0 (The Frame API) with the "Big Tent" strategy for future development. It replaces all previous codenames and version numbers with permanent architectural designations.

# ---

**The RatatuiRuby Ecosystem Strategy**

Version: Final  
Status: Living Constitution

## **Abstract**

The RatatuiRuby ecosystem is a native interface between the Ruby programming language and the Rust ratatui library. It is designed to provide the performance of systems programming with the ergonomics of Ruby. The ecosystem follows a "Forked Path" architecture: a shared, high-performance Engine (Layer 1\) supports two mutually exclusive application paradigms—The Functional Path (TEA) and The Object-Oriented Path (Components). This document defines the architectural boundaries, design philosophies, and strategic roadmap for the entire project.

## ---

**Chapter 1: The "Big Tent" Strategy**

### **What’s in this Chapter**

* **The Forked Path:** How we support both Functional and Object-Oriented programming without compromise.  
* **The Taxonomy:** Renaming the layers (Engine, TEA, Components, DSL, Trails).  
* **The Philosophy:** Why we reject the "One True Way" in favor of architectural agnosticism.

### **Chapter Summary**

We believe Ruby developers should not have to change their preferred coding paradigm to use our tools. Therefore, we have adopted the "Big Tent" strategy. The ecosystem is built on a shared foundation, the **Engine**, but splits immediately above it.  
**Path A (The Functional Path)** is for developers who prefer immutability, pure functions, and the Elm Architecture. It is ideal for CLI tools, developer utilities, and high-reliability state machines. **Path B (The Object-Oriented Path)** is for developers who prefer encapsulation, stateful objects, and "Rails-like" structure. It is ideal for complex dashboards, enterprise platforms, and large teams.  
These paths are distinct. You do not mix them. You choose the architecture that fits your domain at the start of your project. By supporting both, RatatuiRuby positions itself not just as a library, but as the universal runtime for Terminal User Interfaces in Ruby.

## ---

**Chapter 2: The Constitution**

### **What’s in this Chapter**

* **Native Performance:** Our commitment to Rust FFI over porting logic to Ruby.  
* **Ruby Idioms:** How we expose Rust power without Rust syntax.  
* **Zero Runtime Conflict:** Why we reject bridging managed runtimes (like Go).  
* **Dependency Hygiene:** The "Batteries Included, But Swappable" rule.

### **Chapter Summary**

This project creates a native bridge. We do not rewrite Ratatui in Ruby; we wrap it. This decision guarantees performance. Rust handles the heavy lifting—rendering, layout calculation, and buffer writing—where it creates zero garbage and runs at machine speed. Ruby handles the high-level logic, where its expressiveness shines.  
We reject the "Porting" approach used by competitors. We do not run the Go runtime alongside Ruby. We run pure machine code. This ensures thread safety and predictable memory usage. We also adhere to strict dependency hygiene. We rely on the Ruby Standard Library wherever possible. We build for the future of Ruby (Ractors/Ruby 4.0) today. We prioritize correctness over convenience, and performance over features.

## ---

**Chapter 3: Layer 1 \- The Engine (ratatui\_ruby)**

### **What’s in this Chapter**

* **The Frame API:** The canonical method for rendering (draw { |frame| ... }).  
* **Immediate Mode:** Understanding the render loop.  
* **Layout & Hit Testing:** Solving the "Footgun" via explicit Frame control.  
* **Primitives:** Text measurement, cursor control, and event polling.

### **Chapter Summary**

The Engine is the bedrock. It is a stateless, immediate-mode renderer. As of v1.0.0, its primary interface is the **Frame API**. This mirrors the native Rust architecture. When a developer calls draw, the Engine yields a Frame object. This object gives the developer explicit control over where widgets are drawn using frame.render(widget, area).  
This design solves the "Layout/Hit-Test" synchronization problem. Developers calculate the layout once inside the draw block, render their widgets into those areas, and cache the areas for the subsequent event loop. This ensures that what is drawn and what clicks are detected are mathematically identical. The Engine also provides essential primitives: precise text width measurement for auto-sizing, hardware cursor positioning for text inputs, and non-blocking event polling. The Engine knows nothing of "Buttons" or "State." It only knows geometry and drawing.

## ---

**Chapter 4: Layer 2A \- The Functional Path (ratatui\_ruby-tea)**

### **What’s in this Chapter**

* **The Elm Architecture (TEA):** Model, View, Update.  
* **Jujube Redux:** The implementation specification (Procs over Classes).  
* **Concurrency:** "Sync Logic, Async Work."  
* **Ractor Readiness:** The "Trojan Horse" enforcement of immutability.

### **Chapter Summary**

The Functional Path brings the Elm Architecture to Ruby. We call this implementation **Jujube Redux**. It rejects complex class hierarchies in favor of Ruby's native data structures. Commands are Procs. Batches are Arrays. The logic is simple: Data In, Data Out.  
To ensure performance, we enforce a strict separation of concerns: "Sync Logic, Async Work." The main thread handles the Model updates and View generation. These must be pure and fast. All side effects—HTTP requests, database queries, timers—are offloaded to a worker pool via Commands.  
We are building this layer for the future. While it runs on Threads today, it enforces **Ractor-safety**. The runtime validates that all Models and Messages are deeply frozen and shareable. If a developer attempts to pass mutable state in a message, the runtime errors immediately. This "Trojan Horse" strategy ensures that when Ruby 4.0 arrives, our ecosystem will be ready without a single line of user code changing.

## ---

**Chapter 5: Layer 2B \- The Object-Oriented Path (ratatui\_ruby-components)**

### **What’s in this Chapter**

* **Retained Mode:** Simulating persistent objects on top of an immediate mode engine.  
* **The Component Lifecycle:** mount, render, handle\_event.  
* **The Focus Manager:** Handling Tabbing and keyboard routing.  
* **Hit Testing:** Using the Frame API to route mouse events.

### **Chapter Summary**

The Object-Oriented Path adapts the stateless Engine into a stateful **Component Kit**. It bridges the gap between how computers draw (pixels every frame) and how humans think (persistent buttons). A Component is a Ruby object that retains state—like focused or input\_text.  
Every frame, the Component generates a transient render tree using the Engine's primitives. It uses the Frame API to calculate exactly where it is on the screen, enabling precise hit testing for mouse events. A central Focus Manager tracks which component is active, routing keyboard events only to that specific object. This layer enables "Rails-like" development, where complex UIs are composed of small, reusable, self-contained classes.

## ---

**Chapter 6: Layer 3 \- The Syntax (glimmer-dsl-ratatui)**

### **What’s in this Chapter**

* **Declarative UI:** Separating structure from logic.  
* **The Bridge:** How the DSL adapts to both Path A and Path B.  
* **Data Binding:** Unidirectional (TEA) vs. Bidirectional (Components).  
* **Composition:** Eliminating boilerplate.

### **Chapter Summary**

Glimmer is the syntax layer. It is not a new framework; it is a description language. It allows developers to visualize the hierarchy of their UI by looking at the indentation of their code.  
Crucially, the DSL serves both architectural paths. For **Path A (TEA)**, it provides a clean way to generate the View tree from the immutable Model. It uses unidirectional data binding—changes in the model update the view. For **Path B (Components)**, it provides a powerful composition tool. It allows developers to define complex component trees with bidirectional data binding, linking the View directly to the Component's state. It transforms verbose object instantiation into elegant, readable Ruby code.

## ---

**Chapter 7: Layer 4 \- The Framework (ratatui\_ruby-trails)**

### **What’s in this Chapter**

* **The "Rails" Experience:** Generators, conventions, and structure.  
* **The App Loop:** Integrating the Database, Jobs, and UI.  
* **Asset Management:** Themes and Styles.  
* **The Future:** What a "Full Stack" TUI looks like.

### **Chapter Summary**

Trails is the realization of the "Rails for TUI" vision. It is an opinionated framework that wires the entire ecosystem together. It assumes you are building a database-backed application. It provides the standard directory structure, the boot process, and the integration with ActiveRecord and background job processors.  
Trails is the final abstraction. It hides the wiring. A developer runs trails new, defines a Model, and gets a running TUI application. It chooses the "Blessed" path—typically Layer 2B (Components)—as the default for scalable application development, while allowing advanced users to drop down to Layer 2A (TEA) for specific subsystems.

## ---

**Chapter 8: The Roadmap**

### **What’s in this Chapter**

* **Sequencing:** Why we build in serial, not parallel.  
* **Phase 1:** The Functional Path (TEA).  
* **Phase 2:** The Component Path.  
* **Phase 3:** The DSL and Framework.

### **Chapter Summary**

We execute serially to ensure quality. We cannot build the DSL before the Components exist. We cannot build the Components before the Engine is stable.  
Our immediate focus is **Path A (ratatui\_ruby-tea)**. This allows us to capture the CLI tool market quickly and validate the Engine's capabilities with a lightweight runtime. Once stable, we will build **Path B (ratatui\_ruby-components)**, unlocking the enterprise market. Finally, we will layer the **DSL** and **Framework** on top, completing the ecosystem. This roadmap prevents technical debt by ensuring each layer is battle-tested before the next relies upon it.

## ---

**Chapter 9: Market Positioning**

### **What’s in this Chapter**

* **Vs. CharmRuby:** Native vs. Ported.  
* **Vs. Rust:** Flexibility vs. Strictness.  
* **Vs. Go:** Abstraction vs. Simplicity.  
* **The Pitch:** "The Universal Runtime."

### **Chapter Summary**

RatatuiRuby is unique. Unlike CharmRuby, we do not port Go libraries; we provide a native Rust engine. This avoids runtime conflicts and maximizes performance. Unlike writing raw Rust, we offer the iteration speed of Ruby. Unlike writing Go, we offer the rich abstraction capabilities of the Ruby ecosystem.  
We are the "Universal Runtime." Whether you are a functional programmer who loves the purity of Elm, or an object-oriented architect who loves the structure of Rails, RatatuiRuby is your home. You do not have to choose a different engine to change your style. We provide one engine, with many paths.