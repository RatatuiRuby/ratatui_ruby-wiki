<!--
  SPDX-FileCopyrightText: 2026 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

This specification is **excellent**. It is lean, focused, and perfectly aligned with the "Universal Runtime" strategy.  
By rejecting complex class hierarchies in favor of Ruby primitives (Proc, Array, Loop), you have designed a system that feels like "Ruby" rather than "Elm ported to Ruby."  
Here is my formal approval and a few minor technical refinements to "Jujube Redux" before we build.

### **Critique & Refinements**

1. **The Missing init:**  
   * **Observation:** Section 4.1 (TEA.run) takes model, update, and view, but misses init.  
   * **Risk:** Users cannot trigger side effects (like fetching data) immediately upon application start.  
   * **Fix:** Add init: nil to the arguments. It should accept a Cmd (Proc) to run immediately.  
2. **The Cmd.quit Signal:**  
   * **Observation:** You use RatatuiRuby::TEA::Cmd.quit.  
   * **Refinement:** Make sure this doesn't actually spin up a thread. The Runtime loop should check the *return value* of the command.  
   * *Implementation Detail:* Cmd.quit returns a special Singleton (:\_\_quit\_\_). The Runtime loop sees this token in the command list and breaks the loop *before* sending it to a worker.  
3. **The "Batch" Alias:**  
   * **Observation:** You rightly identify Arrays as batches.  
   * **Suggestion:** Add Cmd.batch(cmds) as a pass-through helper. Why? Because users coming from Elm/BubbleTea search for "batch." It costs zero lines of code (def self.batch(\*cmds); cmds.flatten; end) and improves discovery.

### ---

**Implementation Plan: Gem 1.25 (ratatui-tea)**

We will execute this immediately following the Gem 1.0 "Missing 4" features.  
**Phase 1: The Engine Update (Gem 1\)**

* **Task:** Update RatatuiRuby.poll\_event to accept a timeout: float argument in Rust.  
* **Why:** Without this, the Main Thread blocks forever, and we cannot process Worker Queue messages (HTTP responses) until the user presses a key.

**Phase 2: The Runtime (Gem 1.25)**

* **Task:** Implement RatatuiRuby::TEA.run.  
* **Logic:** The "Fast Loop" (Render \-\> Non-blocking Queue Pop \-\> Blocking Poll with Timeout \-\> Update).

**Phase 3: The Batteries (Gem 1.25)**

* **Task:** Implement RatatuiRuby::TEA::Cmd module.  
* **Methods:** exec, wait, map, batch.

**Phase 4: The Documentation**

* **Task:** Create a README.md that explicitly contrasts "Flavor A" (Script) vs "Flavor B" (Service).

### ---

**Strategic Note**

This specification effectively "commoditizes" the Elm Architecture. By shipping this as a tiny, highly performant layer on top of your Rust engine, you remove the primary reason to use charm-ruby (the architecture) while retaining the superior performance of ratatui\_ruby.  
**Are you ready to switch to "Implementation Mode" and start coding the P0 blocker (poll\_event)?**