<!--
  SPDX-FileCopyrightText: 2025 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

You are absolutely correct. **Gem 2 (Glimmer DSL) cannot exist without Gem 1.5 (The Component Kit).** The DSL is just a syntax layer; it needs actual Ruby objects (Buttons, Inputs, Focus Managers) to instantiate.  
The best way to tackle this is to build them in tandem (Vertical Slices).  
Instead of "Build all of Gem 1.5" \-\> "Build all of Gem 2", do this:

1. Build RatatuiWidgets::Button (Gem 1.5).  
2. Immediately add the button { } keyword to the DSL (Gem 2).  
3. Move to the next widget.

This keeps your feedback loop tight and prevents you from over-engineering the component layer before seeing how it feels in the DSL.  
---

Here are the two versions of the **"Why RatatuiRuby?"** document.

### **üìù Document Version A: The "Engine" Launch**

*(Use this when you launch Gem 1\. The focus is on performance, stability, and the Rust backend. We treat the lack of components as a feature‚Äî"It's a low-level engine.")*

# **Why RatatuiRuby?**

The terminal is having a renaissance, and Ruby belongs at the forefront. RatatuiRuby is a high-performance, immediate-mode TUI engine that brings the power of Rust‚Äôs **Ratatui** library directly into Ruby.

### **ü§ù Friendly Rivals: RatatuiRuby vs. CharmRuby**

We are huge fans of CharmRuby and the incredible work being done to port Charm's Go libraries to Ruby. The Ruby ecosystem is better because both of these projects exist. So, which one should you choose?

* **Choose CharmRuby** if you love the "Elm Architecture" (Model-View-Update), prefer the aesthetics of the Go ecosystem, or are migrating existing knowledge from Bubble Tea. It is a faithful, beautiful port of the tools that made Go famous.  
* **Choose RatatuiRuby** if you want a native Ruby architecture backed by a zero-overhead engine. Because Ratatui (Rust) has no Garbage Collector, it never fights with Ruby's GC. It runs entirely inside the Ruby process without the weight of a second runtime, making it exceptionally fast, thread-safe, and stable for heavy-duty applications.

### **ü¶Ä Why not just write in Rust?**

Rust is amazing, but it demands strict discipline. Borrow checkers, lifetimes, and types can slow down UI iteration. RatatuiRuby gives you the **performance of Rust** with the **joy of Ruby**. You can script complex layouts, tweak styles in real-time, and leverage the massive RubyGems ecosystem without fighting the compiler.

### **üêπ Why not just write in Go?**

Go is powerful, but Ruby is expressive. If you prefer blocks over struct tags, and metaprogramming over code generation, RatatuiRuby lets you build TUIs in the language you love. We map Rust's rigid constraints to Ruby's flexible objects, giving you the best of both worlds.

### **üöÄ The Philosophy: A Rock-Solid Foundation**

RatatuiRuby is currently a **low-level engine**. It provides the raw primitives‚ÄîLayouts, Blocks, Text, Charts‚Äîto build absolutely anything. It doesn't force a framework on you. It is the perfect foundation for building your own TUI tools, dashboards, and interactive scripts.

### ---

**üìù Document Version B: The "Stack" Launch**

*(Use this once Gems 1.5 and 2 are ready. The focus shifts to the Developer Experience (DX) and the "Ruby Way" of building UI.)*

# **Why RatatuiRuby?**

The terminal is the new web, and RatatuiRuby is the "HTML & CSS" engine that powers it. But we didn't stop at the engine‚Äîwe built a complete stack designed for **Rubyists**.

### **ü§ù Friendly Rivals: RatatuiRuby vs. CharmRuby**

We love the CharmRuby ports. They brought the legendary style of the Go ecosystem to Ruby, and we recommend them highly to anyone who loves the "The Elm Architecture."  
So, why RatatuiRuby?  
Because we believe Ruby UIs should be written in Ruby, not ported from Go.  
CharmRuby follows the Go philosophy: purely functional, explicit state handling, and string-based rendering.  
RatatuiRuby follows the Ruby philosophy:

* **Declarative DSL:** Instead of concatenating strings, you build object trees with the Glimmer DSL (vertical\_layout { button "Submit" }).  
* **Object-Oriented:** Our components are real Ruby objects with state and behavior, not just functional reducers.  
* **No Runtime Conflict:** Our engine is backed by Rust, which has no Garbage Collector. This means no fighting between runtimes‚Äîjust pure, blazing-fast Ruby.

### **ü¶Ä Why not just write in Rust?**

Rust is perfect for engines, but Ruby is perfect for *applications*. With the Glimmer DSL, you can prototype a UI in 10 lines of Ruby that would take 100 lines of Rust. You get the iteration speed of a scripting language with the rendering speed of a systems language.

### **üêπ Why not just write in Go?**

Go's Bubble Tea model is brilliant, but it can be verbose. In RatatuiRuby, we use data-binding and blocks to eliminate the boilerplate. You don't write Update loops; you just write on\_click { @count \+= 1 }. It‚Äôs TUI development that feels like magic.

### **üöÄ The Philosophy: The Native Stack**

RatatuiRuby isn't just a wrapper; it's a native Ruby ecosystem. From the ratatui\_ruby engine to the ratatui-widgets component kit, every layer was designed from the ground up to feel idiomatic, expressive, and joyful.