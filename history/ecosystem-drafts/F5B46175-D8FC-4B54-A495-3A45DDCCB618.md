<!--
  SPDX-FileCopyrightText: 2026 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

Here is the consolidated **Ecosystem Strategy & Architecture Guide**. It integrates Proposal 3 (Frame-based Rendering) and the Gem 1.25 Specification (Jujube Redux) into a single, unified constitutional document.

# ---

**The RatatuiRuby Ecosystem: Constitution & Strategy Guide**

Version: 2.0 (The "Big Tent" Era)  
Status: Living Document  
Audience: Leadership, Architects, Contributors, & Future Agents

## ---

**Chapter 1: The Grand Strategy**

### **Chapter Summary**

We are building the universal terminal interface runtime for Ruby. We reject the false dichotomy between "Functional" and "Object-Oriented" architectures. We believe a robust engine can support both.  
Our ecosystem is not a port of Go or Rust libraries. It is a native Ruby bridge to the industry-standard Ratatui engine. We prioritize performance (Rust FFI), stability (no runtime fighting), and Ruby ergonomics. Our strategy is the "Big Tent": we offer a shared high-performance core (Layer 1), then split into two distinct, optimized paths for application development (Layer 2). Users choose their architecture based on their problem, not their renderer.

### **What’s in this Chapter**

* **The Vision:** Moving beyond "scripts" to "applications."  
* **The "Big Tent" Philosophy:** Why we support both TEA (The Elm Architecture) and OOP (Components).  
* **Competitive Positioning:**  
  * **Vs. CharmRuby:** Native extension vs. Go/Ruby runtime bridge.  
  * **Vs. Raw Rust:** Ruby productivity vs. Rust strictness.  
* **The "Forked Path" Topology:** Visualization of the split after Layer 1\.

## ---

**Chapter 2: The Architecture Map & Taxonomy**

### **Chapter Summary**

The ecosystem is structured into four vertical layers. Layer 1 is the foundation. Layers 2A and 2B are mutually exclusive application runtimes. Layers 3 and 4 build upon these runtimes to provide syntax sugar and framework conventions.  
We enforce strict naming conventions to ensure discoverability and namespace hygiene. All gems utilize the ratatui\_ruby namespace, with the exception of the DSL, which adopts glimmer- to align with the Glimmer ecosystem.

### **What’s in this Chapter**

* **Layer 1 (The Engine):** ratatui\_ruby. The stateless Rust wrapper.  
* **Layer 2A (The Tea):** ratatui\_ruby-tea. The functional runtime.  
* **Layer 2B (The Kit):** ratatui\_ruby-components. The object-oriented kit.  
* **Layer 3 (The Syntax):** glimmer-dsl-ratatui. The declarative adapter.  
* **Layer 4 (The Framework):** ratatui\_ruby-trails. The MVC structure.  
* **Dependency Graph:** A visual guide to how gems reference each other.

## ---

**Chapter 3: Layer 1 — The Engine (ratatui\_ruby)**

### **Chapter Summary**

Layer 1 is the "Metal." It wraps the Rust ratatui crate via Magnus. It is strictly **Immediate Mode**. It draws a frame and forgets it. It holds no application state.  
To support the ecosystem, Layer 1 adopts a **Frame-Based API** (Proposal 3). This mirrors the native Rust API (f.render\_widget). It gives developers explicit control over layout and rendering order. It returns computed geometry (Rects) during the draw pass, solving the "hit-testing" problem without requiring layout duplication.

### **What’s in this Chapter**

* **The Frame API:** RatatuiRuby.draw { |frame| ... }.  
  * Why we chose it over declarative trees for the core.  
  * How it solves the "Hit Test Footgun."  
* **The Tree API Helper:** RatatuiRuby.draw(tree).  
  * Legacy support for TEA (Layer 2A).  
* **Critical Primitives:**  
  * **Text Measurement:** Text.width(str) for auto-sizing.  
  * **Cursor Control:** frame.set\_cursor(x, y) for inputs.  
  * **Event Handling:** Non-blocking poll\_event(timeout:).  
  * **Modifiers:** Shift/Ctrl/Alt support in key events.

## ---

**Chapter 4: Layer 2A — The Functional Path (ratatui\_ruby-tea)**

### **Chapter Summary**

This is the "Jujube Redux" specification. It implements The Elm Architecture (TEA) for Ruby. It relies on the principle of "Data In, Data Out."  
This layer is optimized for CLI tools, developer utilities, and high-control state machines. It uses Layer 1's Tree API helper to render views. It enforces a strict concurrency model: **Sync Logic, Async Work**. All updates happen on the main thread; all side effects (Commands) run on a worker pool. To prepare for Ruby 4.0 Ractors, we enforce that all Messages and Models must be deeply frozen (Shareable).

### **What’s in this Chapter**

* **Core Philosophy:** No base classes. Callable objects only.  
* **The Loop:** The Program class, the main thread update, and the worker thread dispatch.  
* **Ractor Safety:** The "Trojan Horse" enforcement of immutable state.  
* **Fractal Architecture:** How to compose models to prevent monolithic case statements.  
* **Batteries Included:** Built-in Cmd factories for shell execution and timers.

## ---

**Chapter 5: Layer 2B — The Component Path (ratatui\_ruby-components)**

### **Chapter Summary**

This layer implements a **Retained Mode** system on top of the Immediate Mode engine. It introduces the concept of long-lived Component objects that maintain their own state (focus, input value, hover status).  
This layer leverages Layer 1's **Frame API**. Components calculate their own layout logic. When a component renders, it tells the Frame exactly where to draw. It stores that location. When input events occur, the Component Manager checks those stored locations to route clicks and keypresses to the focused element.

### **What’s in this Chapter**

* **The Component Lifecycle:** mount, render, handle\_event.  
* **The Focus Manager:** Tabbing, focus cycling, and "Focus Trap" logic for modals.  
* **Hit Testing:** Using Frame-returned Rects to route mouse events.  
* **Reconciliation:** How stateful objects generate ephemeral Layer 1 structs every frame.

## ---

**Chapter 6: Layer 3 — The Syntax (glimmer-dsl-ratatui)**

### **Chapter Summary**

Layer 3 is the syntax sugar. It does not introduce new architectural patterns; it makes the existing ones readable. It uses Ruby's advanced metaprogramming to create a declarative Domain Specific Language (DSL).  
It acts as an adapter for **both** Layer 2A and Layer 2B.

* **For TEA (2A):** It provides a clean way to build the View Tree (vertical\_layout { ... }). Data binding is strictly **Unidirectional** (Read-Only).  
* **For Components (2B):** It allows full component composition. Data binding is **Bidirectional** (value \<= \[model, :name\]), keeping the View and Component State in sync automatically.

### **What’s in this Chapter**

* **The Two Dialects:** Unidirectional (TEA) vs. Bidirectional (Components).  
* **Component Composition:** How the DSL instantiates Layer 2B objects.  
* **Protocol Interop:** Reserving Msg::FieldUpdated for future TEA compatibility.  
* **"No Magic" Rule:** The DSL compiles down to standard Layer 1/2 API calls.

## ---

**Chapter 7: Layer 4 — The Framework (ratatui\_ruby-trails)**

### **Chapter Summary**

This is "Rails for the Terminal." It is an opinionated framework that scaffolds applications, manages configuration, and integrates with the database (Active Record).  
It focuses heavily on the **Component Path (Layer 2B)**, as this aligns best with the MVC pattern familiar to Rails developers. However, it supports generating "TEA Controllers" for specific isolated tools within a larger application.

### **What’s in this Chapter**

* **Directory Structure:** app/models, app/views, app/components.  
* **The Application Loop:** Booting the engine, managing the database connection.  
* **Generators:** trails generate component, trails generate scaffold.  
* **Testing:** RSpec integration for "Headless Browser" testing of TUI flows.

## ---

**Chapter 8: Roadmap & Execution**

### **Chapter Summary**

We execute serially. We do not build higher layers until the foundation is solid. This is the "Onion Peel" strategy: we cure the core, then the next layer, then the skin.

### **What’s in this Chapter**

1. **Phase A (The Engine):** Ship ratatui\_ruby v1.0. Implement Frame API, Text Width, Cursor, and Non-blocking Poll.  
2. **Phase B (The Functional Path):** Ship ratatui\_ruby-tea. Prove the engine works. Capture the CLI market.  
3. **Phase C (The Component Path):** Ship ratatui\_ruby-components. Implement the base Component class and Focus Manager.  
4. **Phase D (The Syntax):** Ship glimmer-dsl-ratatui. Alpha release supporting TEA views first, then full Component binding.  
5. **Phase E (The Framework):** Ship ratatui\_ruby-trails. The final "Rails" experience.

---

