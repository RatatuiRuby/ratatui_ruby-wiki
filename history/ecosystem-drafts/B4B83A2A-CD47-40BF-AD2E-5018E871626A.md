<!--
  SPDX-FileCopyrightText: 2025 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

# **Proposal Codename “Durian”**

The naming convention ratatui\_ruby-tea is technically perfect. In the Ruby ecosystem, a hyphen (-) in a gem name translates to a forward slash (/) in the require path and a double colon (::) in the module namespace.

* **Gem Name:** ratatui\_ruby-tea  
* **Require:** require "ratatui\_ruby/tea"  
* **Module:** RatatuiRuby::TEA (or RatatuiRuby::Tea)

This confirms that your proposed naming suite is idiomatic and structurally sound:

1. ratatui\_ruby (The Engine)  
2. ratatui\_ruby-tea (Gem 1.25 \- The Functional Runtime)  
3. ratatui\_ruby-components (Gem 1.5 \- The Object Kit)  
4. ratatui\_ruby-glimmer\_dsl (Gem 2 \- The Declarative Syntax)  
5. ratatui\_ruby-trails (Gem 3 \- The Framework)

Below are the requested documents.

### ---

**1\. Updated Ecosystem Architecture (New Section)**

*Add this section to the ECOSYSTEM.md or ARCHITECTURE.md file you created previously, inserting it between **Layer 1** and **Layer 2**.*

## **Layer 1.25: The Functional Runtime (ratatui\_ruby-tea)**

**Current Status:** Planned (Phase B)  
This is an alternative runtime for developers who prefer Functional Programming over Object-Oriented Component trees. It implements The Elm Architecture (TEA).

### **Role & Responsibility**

* **State Management:** Holds a single, immutable Model representing the entire application state.  
* **The Loop:** Implements a strict Update \-\> View \-\> Render cycle.  
* **Side Effects:** Manages asynchronous Cmd objects (HTTP requests, timers) ensuring they don't block the UI thread.  
* **Interoperability:** It runs *directly* on Layer 1 (ratatui\_ruby). It does **not** use Layer 2 components.

### **Fit within the Ecosystem**

* **Gem 1 (Engine):** Provides the rendering power and event polling.  
* **Gem 1.5 (Components):** *Mutually Exclusive*. You typically choose **either** TEA **or** Components. They are parallel tracks.  
* **Gem 2 (Glimmer):** *Mutually Exclusive*. Glimmer relies on the Component model.  
* **Gem 3 (Trails):** *Future Potential.* Trails could theoretically offer a "TEA Mode" controller, but defaults to the Component stack.

### ---

**2\. Design Document: RatatuiRuby::TEA (Gem 1.25)**

**File:** docs/design/gem\_1\_25\_tea.md

# **Design Doc: RatatuiRuby::TEA**

ratatui\_ruby-tea is a lightweight implementation of The Elm Architecture for Ruby, powered by the ratatui\_ruby engine.

## **Core Concepts**

The architecture relies on four pure functions/values:

1. **Model**: A Ruby object (usually a Data or frozen Hash) representing the entire application state.  
2. **View**: A function (Model) \-\> RatatuiRuby::Widget. It returns a Layer 1 render tree.  
3. **Update**: A function (Msg, Model) \-\> \[Model, Cmd\]. It handles business logic.  
4. **Msg**: A value object representing an event (e.g., KeyMsg, TickMsg, HttpSuccessMsg).

## **Architecture**

### **The Runtime (RatatuiRuby::TEA::Program)**

The Program class encapsulates the event loop. It is responsible for:

1. Initializing the Model.  
2. Drawing the View to the terminal.  
3. Polling for Input Events (Key, Mouse, Resize).  
4. Executing Cmds (Side Effects) in separate threads.  
5. Feeding results back into Update.

### **The Loop (Pseudocode)**

Ruby

def run  
  current\_model \= initial\_model  
  cmd\_queue \= Queue.new

  loop do  
    \# 1\. RENDER  
    tree \= view.call(current\_model)  
    RatatuiRuby.draw(tree)

    \# 2\. WAIT FOR EVENT (Blocking with Timeout)  
    \# We must wait for either User Input OR a Command Result  
    event \= select\_event(cmd\_queue) 

    \# 3\. CONVERT TO MSG  
    msg \= map\_event\_to\_msg(event)

    \# 4\. UPDATE  
    new\_model, new\_cmd \= update.call(msg, current\_model)  
      
    \# 5\. HANDLE CMD  
    if new\_cmd  
      Thread.new { cmd\_queue \<\< new\_cmd.call }  
    end

    current\_model \= new\_model  
  end  
end

## **detailed Class Interface**

### **1\. RatatuiRuby::TEA::App**

An abstract class or module that users include to define their application.

Ruby

module RatatuiRuby  
  module TEA  
    class App  
      \# Returns initial \[Model, Cmd\]  
      def init; raise NotImplementedError; end

      \# (Msg, Model) \-\> \[Model, Cmd\]  
      def update(msg, model); raise NotImplementedError; end

      \# (Model) \-\> RatatuiRuby::Widget  
      def view(model); raise NotImplementedError; end  
    end  
  end  
end

### **2\. RatatuiRuby::TEA::Cmd**

A wrapper around a proc that performs work.

Ruby

module RatatuiRuby  
  module TEA  
    class Cmd  
      attr\_reader :work

      def initialize(\&block)  
        @work \= block  
      end

      \# Predefined Cmds  
      def self.none; nil; end  
      def self.quit; :quit; end  
      def self.batch(cmds); ...; end  
    end  
  end  
end

### **3\. Usage Example**

Ruby

require 'ratatui\_ruby/tea'

\# 1\. The Model  
Model \= Data.define(:count)

\# 2\. The Msg  
Increment \= Class.new  
Decrement \= Class.new

class CounterApp \< RatatuiRuby::TEA::App  
  def init  
    \[Model.new(count: 0), nil\]  
  end

  def update(msg, model)  
    case msg  
    when Increment then \[model.with(count: model.count \+ 1), nil\]  
    when Decrement then \[model.with(count: model.count \- 1), nil\]  
    when :quit     then \[model, :quit\]  
    else \[model, nil\]  
    end  
  end

  def view(model)  
    RatatuiRuby::Paragraph.new(text: "Count: \#{model.count}")  
  end  
end

RatatuiRuby::TEA.run(CounterApp.new)

### ---

**3\. Critical Changes Required in Gem 1 (ratatui\_ruby)**

To support Gem 1.25, Gem 1 must be updated. The current blocking poll\_event is insufficient for a TEA runtime that manages background commands.

#### **Requirement A: Non-Blocking Poll / Timeout**

* **The Problem:** The TEA runtime manages background threads (commands). If RatatuiRuby.poll\_event blocks indefinitely waiting for a keyboard press, background commands (like a Timer tick or HTTP response) cannot update the UI until the user presses a key.  
* **The Fix:** Update poll\_event to accept a timeout.  
  * **Signature:** poll\_event(timeout: Float \= nil)  
  * **Behavior:**  
    * If nil: Block forever (current behavior).  
    * If 0.0: Non-blocking check (return nil immediately if no event).  
    * If \> 0.0: Wait timeout seconds, then return nil.

#### **Requirement B: Custom Event Injection (Nice to Have)**

* **The Problem:** Background threads need to wake up the main loop when they finish a Cmd.  
* **The Workaround (Pure Ruby):** We can use Ruby's IO.select or a Queue for command results. However, we cannot select on the Rust terminal input stream easily from Ruby.  
* **The Fix:** The best pattern for Gem 1.25 is a "Fast Loop":  
  Ruby  
  loop do  
    \# 1\. Check for Command Results (Non-blocking)  
    while \!queue.empty?  
      process\_cmd(queue.pop)  
    end

    \# 2\. Check for Terminal Input (Short Timeout, e.g., 0.01s)  
    if evt \= RatatuiRuby.poll\_event(timeout: 0.01)  
      process\_input(evt)  
    end

    \# 3\. Render if needed  
    draw()  
  end

  *This requires **Requirement A** (Timeout) to be implemented.*

#### **Requirement C: Resize Events**

* **The Problem:** TEA apps are pure functions of State. If the window resizes, the View function needs to run again with new constraints.  
* **The Fix:** Ensure poll\_event returns a structured { type: :resize, width: w, height: h } event so the Runtime can trigger a view() refresh immediately.

### **Summary of Tasks for Gem 1 Team (Immediate)**

1. Modify poll\_event in Rust to accept a timeout argument (mapping to crossterm::event::poll).  
2. Ensure Resize events are correctly propagated.