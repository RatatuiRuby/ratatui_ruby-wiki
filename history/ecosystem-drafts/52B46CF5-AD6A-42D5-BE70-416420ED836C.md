<!--
  SPDX-FileCopyrightText: 2026 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

Here is the unified **Ecosystem Strategy & Architecture Constitution**.  
This document serves as the "Source of Truth" for the RatatuiRuby project. It synthesizes the v1.0.0 launch state (Proposal 3 implementation), the "Big Tent" strategy, and the "Jujube Redux" specification for the functional runtime.

# ---

**The RatatuiRuby Constitution: Ecosystem Strategy & Architecture**

Version: 1.0.0 (Post-Launch Baseline)  
Status: Ratified  
Scope: Gem 1 through Gem 3

## ---

**Chapter 1: The "Big Tent" Vision**

### **What’s in this Chapter**

* The market problem: The ideological split between Object-Oriented (OO) and Functional Programming (FP).  
* The "Forked Path" solution.  
* The four distinct user personas we serve.  
* The 5-Layer Ecosystem Taxonomy.

### **Chapter Summary**

Terminal UI development suffers from a paradigm lock. You either use **The Elm Architecture** (functional, immutable, state-machine driven) or **Object-Oriented Components** (stateful, encapsulated, retained mode). Rubyists are divided. Some love the functional purity of tools like Bubble Tea. Others love the "Legos" approach of Rails and Glimmer.  
We refuse to pick a side. Instead, we built a **"Big Tent."**  
RatatuiRuby is not just a library; it is a shared runtime. Layer 1 (The Engine) is an unopinionated, high-performance renderer backed by Rust. Above Layer 1, the ecosystem splits into two mutually exclusive paths. **Path A** (Gem 1.25) caters to functional programmers building CLI tools. **Path B** (Gem 1.5) caters to enterprise developers building complex dashboards. Both run on the same engine. Both benefit from the same performance.  
We serve four personas:

1. **The Junior Dev:** Needs safety. They choose Path A (TEA) because it is a checklist that is hard to break.  
2. **The Frontend Dev:** Wants React. They choose Path B (Components) because it manages state trees.  
3. **The Polyglot:** Wants specific tools. They use Path A for scripts and Path B for platforms.  
4. **The Omakase Rubyist:** Wants a standard. We give them TUIsonTrails (Gem 3), which standardizes Path B.

## ---

**Chapter 2: Layer 1 — The Engine (ratatui\_ruby)**

### **What’s in this Chapter**

* Architecture: Native Rust extension via Magnus.  
* The "Zero Cost" philosophy: No secondary runtime (Go/Java).  
* **The Frame API (Proposal 3):** Imperative rendering control.  
* The "Missing 4" Primitives: Text Measurement, Cursor, Modifiers, Resize.  
* Concurrency Model: The Main Thread Rule.

### **Chapter Summary**

Layer 1 is the metal. It is currently released as ratatui\_ruby v1.0.0. Its job is strict: Render a tree of data to the buffer and poll for events. It has no opinions on how you manage state.  
We architected this layer around **Proposal 3: Frame-Based Rendering**. In early versions, we tried a purely declarative tree. It failed the "Hit Testing" reality check. Developers had to calculate layout geometry twice: once to draw, and once to detect clicks. This was a footgun.  
The v1.0.0 Engine uses a Frame block: RatatuiRuby.draw { |frame| ... }. This mirrors the native Rust Ratatui API. Developers calculate layout once, inside the block. They render widgets explicitly to specific Rects. They save those Rects to instance variables for hit testing. This resolves the duplication problem and gives Layer 1.5 (Components) the precise control it needs to manage focus.  
We also expose the "Missing 4" primitives. We calculate **Text Width** using Rust’s Unicode logic, ensuring Emoji and CJK characters don't break layouts. We allow explicit **Cursor Positioning**, enabling text inputs. We report **Key Modifiers** (Shift/Ctrl) for power-user shortcuts. We propagate **Resize Events** instantly to allow fluid layouts.

## ---

**Chapter 3: Layer 2A — The Functional Path (ratatui\_ruby-tea)**

### **What’s in this Chapter**

* **Codename: Jujube Redux.**  
* The "Just Ruby" Philosophy: Rejecting inheritance for Composition.  
* The "Fast Loop" Algorithm: Sync Logic, Async Work.  
* The "Trojan Horse": Ractor-safety enforcement in v1.0.  
* Canonical Architecture: Model, Update, View.

### **Chapter Summary**

This is Gem 1.25. It targets the "Script" and "Service" personas. It implements **The Elm Architecture (TEA)**, but without the boilerplate typical of static languages.  
We reject base classes. There is no class App \< TEA::App. Instead, we use **Callable Objects**. The runtime accepts any object responding to \#call (Procs, Lambdas, or Service Objects). This allows for radical simplicity. A "Hello World" app is just a hash of three Procs.  
The runtime loop is strict. **Logic is Synchronous; Work is Asynchronous.** The Update function must be pure and fast. It returns a Model and a Command. The Command is just a Proc. The runtime executes the Command on a background thread pool, keeping the UI at 60 FPS. When the Command finishes, it pushes a Message back to the main thread.  
We are future-proofing this gem for Ruby 4.0 using a strategy called **"The Trojan Horse."** While v1.0 runs on Threads, it enforces Ractor safety rules. In Debug mode, the runtime scans every Message and Model. If they are not deeply frozen (Ractor-shareable), it raises an error. When Ruby Ractors mature, we will swap the internal engine to Ractors. User code will not need to change.

## ---

**Chapter 4: Layer 2B — The Component Path (ratatui\_ruby-components)**

### **What’s in this Chapter**

* Retained Mode vs. Immediate Mode reconciliation.  
* The Component Class: State, Mount, Unmount.  
* The "Render Cycle": Generating Layer 1 frames from Layer 2 objects.  
* The Focus Manager: Routing inputs to the active leaf.  
* Hit Testing: Using Layer 1's Frame geometry.

### **Chapter Summary**

This is Gem 1.5. It targets the "Application" persona. It introduces **Retained Mode** concepts to our Immediate Mode engine.  
The core unit is the Component. Unlike Layer 1 widgets (which are throwaway data structs), a Component persists in memory. It has instance variables (@is\_focused, @input\_value). It has a lifecycle (mount, unmount).  
The architectural challenge is bridging state to the renderer. We solve this via the **Render Cycle**. Every frame, the Component Tree is traversed. Each component's view method returns a lightweight Layer 1 struct. The root component collects these and passes them to the Engine.  
Critically, this layer handles **Focus** and **Input Routing**. The Engine broadcasts global events. The Component Layer intercepts them. It maintains a "Focus Path." If the user presses "Enter," the Framework walks the path and delivers the event only to the focused Button. Mouse clicks are handled via Hit Testing, utilizing the precise Rect data returned by Layer 1's Frame API.

## ---

**Chapter 5: Layer 3 — The Syntax (glimmer-dsl-ratatui)**

### **What’s in this Chapter**

* The Role of Glimmer: Declarative syntax over imperative logic.  
* Universal Adapter: Wrapping Layer 2B (Components) vs. Layer 2A (TEA Views).  
* Data Binding: Unidirectional vs. Bidirectional rules.  
* The End Game: "HTML for the Terminal."

### **Chapter Summary**

This is Gem 2\. It is the syntax layer. It makes the code beautiful.  
Writing nested component trees in pure Ruby is verbose (Layout.new(children: \[Button.new...\])). Glimmer solves this. It provides a DSL that looks like the UI structure: vertical\_layout { button { ... } }.  
This DSL is **Universal**.

1. **For Path B (Components):** It offers full bidirectional data binding (value \<= \[model, :name\]). It auto-wires event listeners. It feels like writing a desktop app.  
2. **For Path A (TEA):** It offers a "View Only" mode. It generates the static View tree from the immutable Model. It strictly forbids bidirectional binding, preserving the functional data flow.

We use Glimmer as a "skin." It does not contain logic. It instantiates Layer 2 components or Layer 1 structs. This ensures that a user can always "eject" from the DSL and write pure Ruby if needed.

## ---

**Chapter 6: Competitive Positioning**

### **What’s in this Chapter**

* Tone: Respect and Friendliness.  
* Vs. CharmRuby.  
* Vs. Raw Rust (Ratatui).  
* Vs. Raw Go (Bubble Tea).

### **Chapter Summary**

We operate in a rich ecosystem. We define ourselves not by what we hate, but by what we prioritize.  
Vs. CharmRuby:  
CharmRuby is an impressive achievement. It ports the Go ecosystem to Ruby using FFI. It allows Rubyists to use the "Elm Architecture" patterns they admire from Go.  
Our Distinction: We prioritize Native Performance and Ruby Idioms. CharmRuby bridges two runtimes (Ruby \+ Go), which incurs overhead and GC contention. RatatuiRuby uses Rust, which has no runtime. It is lighter and safer. Furthermore, CharmRuby is strictly "Elm-like." We offer the "Big Tent"—you can use Elm patterns (Gem 1.25) or Component patterns (Gem 1.5).  
Vs. Writing in Rust:  
Rust is the gold standard for performance, but the borrow checker hampers UI prototyping. RatatuiRuby gives you Rust’s rendering engine (Cassowary/Frame) but lets you define logic in Ruby. You iterate faster, with the same frame rate.  
Vs. Writing in Go:  
Go is excellent for CLIs, but it lacks Ruby’s expressiveness and metaprogramming. If your backend is in Ruby (Rails/Sidekiq), writing your TUI in Go requires context switching and code duplication. RatatuiRuby lets you import your ActiveRecord models directly into your TUI.

## ---

**Chapter 7: Execution Roadmap**

### **What’s in this Chapter**

* Current State: v1.0.0 (Engine) is Live.  
* Phase B: The "Quick Win" (Gem 1.25).  
* Phase C: The "Main Event" (Gem 1.5 \+ Gem 2).  
* Phase D: The Framework (Gem 3).

### **Chapter Summary**

We execute serially. We do not build on unstable foundations.  
Status: Phase A Complete.  
Gem 1 (The Engine) is v1.0.0. The Frame API is stable. The primitives are ready.  
Next: Phase B (The Functional Path).  
We will build and ship ratatui\_ruby-tea (Gem 1.25). It is low-effort and high-impact. It immediately provides a "batteries included" framework for script writers.  
Then: Phase C (The Component Path).  
We will build ratatui\_ruby-components (Gem 1.5). This requires significant architecture for state management. Once the core Component class works, we will immediately wrap it with glimmer-dsl-ratatui (Gem 2). We will release them in tandem.  
Finally: Phase D (The Framework).  
When the ecosystem matures, we will release ratatui\_ruby-trails (Gem 3). This is "Rails new." It generates a project structure that pre-configures Layer 1.5 and Layer 2, integrates ActiveRecord, and sets up the testing harness.