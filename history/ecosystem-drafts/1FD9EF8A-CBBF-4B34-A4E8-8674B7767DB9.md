<!--
  SPDX-FileCopyrightText: 2025 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

# **Codename “Jujube”**

### **To: CEO & CTO**

### **From: The Architect**

### **Subject: Re: Concurrency Strategy & Impact Analysis**

**The Concurrency Verdict: The "Node.js" Model (Event Loop)**  
You asked if we should run Update functions off the main thread to ensure buttery performance.  
**My recommendation for v1.0 is: NO.**  
Here is the technical reality of Ruby (MRI) today:

1. **The GIL (Global Interpreter Lock):** Even if we move the Update function to a separate thread, if the user writes computationally heavy code (e.g., sorting a massive list), Ruby’s GIL ensures that thread holds the CPU. The Main Thread (responsible for rendering) will still be blocked waiting for the GIL to release. We gain complexity but no guaranteed frame rate stability.  
2. **The Render Bottleneck:** In many UI apps, the View function (allocating thousands of Ruby objects) is actually slower than the Update function.  
3. **Ractor Readiness:** True parallelism requires Ractors. Since we are waiting for v2.0 for Ractors, simulating this with Threads now introduces race conditions without solving the CPU blocking issue.

The Solution: The Asynchronous IO Model  
We will emulate the Node.js/JavaScript architecture, which is proven for UIs:

1. **The Main Thread** handles the Loop: Input \-\> Update \-\> View \-\> Render. This ensures consistency and simplifies debugging.  
2. **The Worker Threads** handle Cmds. **This is where the butter comes from.**  
   * Documentation must explicitly state: *"Do not calculate Fibonacci sequences in your Update loop. Return a Cmd to do it in the background."*  
   * By aggressively offloading *everything* that isn't pure logic (HTTP, File IO, Heavy Calculation) to Cmd threads, the Main Thread stays free to hit 60 FPS.

**Impact on ratatui\_ruby (Gem 1):**

* **Confirmed Requirement:** We strictly need poll\_event(timeout: Float).  
* **New Requirement:** We need RatatuiRuby::Frame or similar to allow atomic updates, though RatatuiRuby.draw is currently sufficient if it is thread-safe (or only called from Main). No other changes required.

---

*(Attached: Architectural Specification for the TEA Tech Lead)*

# ---

**Architectural Specification: ratatui\_ruby-tea (Gem 1.25)**

Status: APPROVED FOR DEVELOPMENT  
Target Version: 1.0.0  
Engine Requirement: ratatui\_ruby \>= 0.4.0 (Must support poll\_event(timeout:))

## **1\. Executive Summary**

ratatui\_ruby-tea is a runtime implementation of **The Elm Architecture (TEA)** for Ruby. It is designed to sit on top of the ratatui\_ruby engine.  
**The Vision:**

* For **Frontend Converts**: It is "Redux for the Terminal." A single immutable store, unidirectional data flow, and pure render functions.  
* For **Native Rubyists**: It is "The Standard Architecture." It provides a clean separation of concerns (Model \= Database in RAM, Update \= Controller, View \= View) for CLI tools that have outgrown simple scripts.

**Core Philosophy:** "Managed Concurrency." The user writes synchronous, blocking-style logic in their Update function. The Runtime wraps this in a non-blocking event loop that handles IO and input transparently.

## **2\. The Architecture: The Loop**

The application runs in a single loop on the Main Thread, while Side Effects (Commands) run in a Thread Pool.

Code snippet

graph TD  
    User\[User Input\] \--\>|Key/Mouse| Runtime  
    Runtime \--\>|Msg| Update\[User Update Function\]  
    Update \--\>|New Model| Runtime  
    Update \--\>|Cmd| ThreadPool\[Background Thread Pool\]  
    ThreadPool \--\>|Result Msg| Runtime  
    Runtime \--\>|Model| View\[User View Function\]  
    View \--\>|Widget Tree| Engine\[RatatuiRuby Engine\]  
    Engine \--\> Terminal

### **2.1 The "Trojan Horse" (Ractor Safety)**

Although v1.0 uses standard Threads, we must enforce **Ractor constraints** now to enable a seamless upgrade to Ruby 4.0 parallelism later.

* **Rule:** The Model and every Msg passed through the loop **must be Ractor-shareable** (deeply frozen).  
* **Enforcement:** In Development Mode, the Program class will attempt Ractor.make\_shareable(msg). If this fails (e.g., the user passes a socket or mutable String in a message), the app will crash with a descriptive error.

## **3\. Detailed Software Design**

### **3.1 The Program Class**

The heart of the gem. It owns the loop.  
**Responsibilities:**

1. Initialize the application (init).  
2. Poll ratatui\_ruby for input (non-blocking/timeout).  
3. Check the Cmd Queue for results.  
4. Call user Update logic.  
5. Call user View logic.  
6. Render to screen.

**Signature:**

Ruby

class Program  
  \# @param model \[Object\] Initial state (Must be shareable)  
  \# @param update \[Callable\] (Msg, Model) \-\> \[Model, Cmd\]  
  \# @param view \[Callable\] (Model) \-\> RatatuiRuby::Widget  
  \# @param subscriptions \[Callable\] (Model) \-\> Sub (Optional)  
  def initialize(model, update:, view:, subscriptions: nil)  
    \# Validate shareability of model immediately  
  end

  def run  
    \# ... The Event Loop ...  
  end  
end

### **3.2 The Msg Protocol (Data)**

Messages drive the application. We encourage Data classes.

Ruby

\# Standard Practice  
MsgInput \= Data.define(:key)  
MsgTick  \= Data.define(:time)  
MsgHttp  \= Data.define(:status, :body)

### **3.3 The Cmd Architecture (Side Effects)**

A Cmd is a packaged unit of work. It is **not** executed by the user; it is returned to the Runtime.  
The Interface:  
A Cmd is simply an object that responds to \#call and returns a Msg.  
Batteries Included (Standard Lib):  
We must ship these standard commands using only Ruby Standard Library (net/http, open3, fiber).

1. Cmd::Batch.new(\[cmd1, cmd2\]): Run multiple commands.  
2. Cmd::Sequence.new(\[cmd1, cmd2\]): Run in order (conceptually).  
3. Cmd::Wait.new(seconds): Sleep and return a message.  
4. Cmd::Tick.new(interval, msg\_class): A recurring timer.  
5. Cmd::Exec.new(command): Run a shell command asynchronously.  
6. Cmd::NetHttp.get(url, msg\_class): A simple GET request.

The "Plug-and-Play" Wrapper:  
We provide a generic wrapper so users can bring their own libraries (e.g., faraday).

Ruby

\# Usage Example  
Cmd.call do  
  \# This block runs in a background thread  
  result \= MyCustomDb.query("SELECT \* FROM users")  
  Msg::DbResult.new(result)  
end

### **3.4 The Sub Architecture (Subscriptions)**

Subscriptions listen to events that the app does not initiate (e.g., SIGWINCH resize events, or global timers).

* Sub.batch  
* Sub.on\_resize(MsgClass)  
* Sub.every(interval, MsgClass)

## **4\. Developer Experience (DX) & Code Examples**

### **4.1 For the Native Rubyist: "The Standard Architecture"**

*Pitch: This is just a Controller and a Model.*

Ruby

\# app/model.rb  
Model \= Data.define(:counter)

\# app/controller.rb  
class Controller  
  def call(msg, model)  
    case msg  
    when :increment  
      \[model.with(counter: model.counter \+ 1), nil\]  
    when :save  
      \# Return a Cmd to save to DB in background  
      \[model, SaveCmd.new(model)\]  
    end  
  end  
end

\# app/view.rb  
class View  
  def call(model)  
    RatatuiRuby::Paragraph.new(text: "Count: \#{model.counter}")  
  end  
end

RatatuiRuby::TEA::Program.new(  
  Model.new(counter: 0),  
  update: Controller.new,  
  view: View.new  
).run

### **4.2 For the Frontend Convert: "Functional Purity"**

*Pitch: Pure functions and Redux-style reducers.*

Ruby

Model \= Data.define(:count)

Update \= \-\>(msg, model) {  
  case msg  
  when :inc then \[model.with(count: model.count \+ 1), nil\]  
  else \[model, nil\]  
  end  
}

View \= \-\>(model) {  
  RatatuiRuby::Paragraph.new(text: model.count.to\_s)  
}

RatatuiRuby::TEA::Program.new(Model.new(count: 0), update: Update, view: View).run

## **5\. Implementation Roadmap**

### **Phase 1: The Runtime Core**

1. Implement RatatuiRuby::TEA::Program.  
2. Implement the Thread Pool logic for Cmd execution.  
3. Implement Cmd.none and Cmd.call.  
4. **Critical:** Integrate RatatuiRuby.poll\_event(timeout:) to ensure the loop stays alive.

### **Phase 2: Batteries (Standard Lib)**

1. Implement Cmd::Wait, Cmd::Tick, Cmd::Exec.  
2. Implement Cmd::NetHttp (Zero-dependency implementation).

### **Phase 3: Ractor Enforcement**

1. Add the "Development Mode" check that verifies Ractor.make\_shareable on all Models and Msgs.  
2. Add a configuration flag config.ractor\_mode \= false (default) to allow power users to opt-out if necessary.

### **Phase 4: Glimmer Prep**

1. Ensure the view calling logic can handle implicit return values from blocks (standard Ruby behavior, but verify).  
2. (Future-proofing): If glimmer-dsl-ratatui is present, look for a standard protocol (e.g., implicit\_dispatch) to handle value \<= \[model, :key\] syntax by auto-generating messages.

## **6\. Directory Structure**

Plaintext

lib/  
└── ratatui\_ruby/  
    └── tea/  
        ├── cmd/  
        │   ├── exec.rb  
        │   ├── net\_http.rb  
        │   └── tick.rb  
        ├── sub/  
        ├── program.rb    \# The Loop  
        ├── runtime.rb    \# Thread/Ractor Abstraction  
        └── version.rb

## **7\. Final Note to Tech Lead**

Simplicity is the feature.  
Do not over-engineer the Update interface. It is just (Msg, Model) \-\> \[Model, Cmd\].  
Do not try to make the View stateful. It is just (Model) \-\> Tree.  
The complexity lives in the Program class, which manages the ugly reality of Threads and IO so the user never sees it.  
Build the "Happy Path" first: A user creates a counter app, clicks \+, and it updates instantly. Then add the async Cmd support.  
Good luck.