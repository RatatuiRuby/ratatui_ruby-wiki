<!--
  SPDX-FileCopyrightText: 2026 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

To: The CEO of RatatuiRuby  
From: The Council of Architects & The Technical Writer  
Date: December 30, 2025  
Subject: Canonical Architecture Document: ratatui\_ruby-tea (Gem 1.25)  
After rigorous debate within the Council of Architects (chair: Internal Architect; members: Elmer, Reagan, Rainier, Troy, Glinda, Gemma, Gordon, Russel, Angie) and deep scrutiny by your Product and Engineering staff, we have reached **unanimous consensus**.  
We have resolved the "Rails" terminology conflict: **RatatuiRuby on Trails** (Layer 4\) will be the "Rails for the Console." Consequently, **TEA** (Layer 2A) is positioned as the **"Precision Runtime"**â€”optimized for highly interactive CLI tools, state machines, and complex logic flows where "Convention over Configuration" is less important than "Explicit Control."  
The following document is the definitive source of truth.

# ---

**Canonical Architecture: ratatui\_ruby-tea**

Version: 1.0.0 (Gold Master Specification)  
Layer: 2A (The Functional Path)  
Codename: Jujube Prime

## **1\. Executive Vision & Ecosystem Position**

ratatui\_ruby-tea is a high-performance, functional runtime for Terminal User Interfaces. It sits directly atop the ratatui\_ruby engine.  
In the "Big Tent" ecosystem, this gem represents **Path A: The Functional Path**.

* **It is NOT:** A dashboard framework, a component kit, or "Rails."  
* **It IS:** An implementation of **The Elm Architecture (TEA)** adapted for Ruby. It is designed for developers who need **strict determinism**, **managed concurrency**, and **rock-solid state management**.

**Target Use Cases:**

* Complex CLI tools (e.g., git interfaces, database migration wizards).  
* Applications with complex state transitions (installers, games).  
* High-frequency monitoring tools where performance is paramount.

## **2\. Core Philosophy**

### **2.1. "Dispatch, Don't Work"**

To maintain a 60 FPS refresh rate on the Ruby Main Thread, we enforce a strict separation of concerns:

* **Sync Logic (Main Thread):** The Update function must be pure and instant. It calculates the *next* state; it does not *execute* work.  
* **Async Work (Background Threads):** All Side Effects (I/O, HTTP, Timers) are encapsulated in **Commands (Cmd)**. The Runtime executes these in a background thread pool.

### **2.2. The "Trojan Horse" (Ractor Readiness)**

We are building for the future (Ruby 4.0 Ractors) but shipping on the present (Threads).

* **Constraint:** The Runtime enforces that all **Models** and **Messages** are effectively immutable and Ractor-shareable.  
* **Mechanism:** In Development Mode, the Runtime calls Ractor.make\_shareable on messages. If a user passes a mutable object (like a raw File handle) in a message, the application raises a ConcurrencyError.  
* **Payoff:** When the internal engine swaps Threads for Ractors in v2.0, user applications upgrade with zero code changes.

## **3\. System Architecture**

### **3.1. The "Fast Loop" Algorithm**

The RatatuiRuby::TEA::Program class orchestrates the event loop. It balances UI responsiveness with CPU efficiency using a precise timeout strategy.

Ruby

\# Pseudo-code of the Canonical Loop  
loop do  
  \# 1\. RENDER PHASE (Main Thread)  
  \# Pure transformation: Model \-\> Widget Tree  
  \# The View treats the Model as a read-only snapshot.  
  ui\_tree \= @view.call(@model)  
  RatatuiRuby.draw(ui\_tree)

  \# 2\. EVENT PHASE (The Heartbeat)  
  \# We sleep for \~16ms (60 FPS). This yields the GIL to background threads.  
    
  \# Priority A: Check for Background Command Results  
  \# Non-blocking check of the Thread-Safe Queue  
  msg \= @cmd\_queue.pop(non\_blocking: true) rescue nil

  \# Priority B: Check for User Input  
  \# Blocking check with Timeout (P0 Requirement from Gem 1\)  
  unless msg  
    event \= RatatuiRuby.poll\_event(timeout: 0.016)  
    msg \= map\_event\_to\_msg(event) if event  
  end

  \# 3\. UPDATE PHASE (Main Thread)  
  \# Deterministic State Transition  
  if msg  
    \# Enforce Ractor Safety (Debug Mode Only)  
    validate\_shareable\!(msg)   
      
    new\_model, cmd \= @update.call(msg, @model)  
    @model \= new\_model

    \# 4\. DISPATCH PHASE  
    \# Offload side effects to the Worker Pool  
    if cmd  
      Thread.new {  
        result\_msg \= cmd.call  
        @cmd\_queue.push(result\_msg)  
      }  
    end  
  end  
end

## **4\. API Design & Primitives**

We reject class inheritance (class MyApp \< App). We adopt **Composition** via **Callable Objects**.

### **4.1. The Triad**

1. **Model:** A Data object or frozen Hash representing the Single Source of Truth.  
2. **View:** A Proc or Object responding to \#call(model) that returns a RatatuiRuby::Widget.  
3. **Update:** A Proc or Object responding to \#call(msg, model) that returns \[Model, Cmd\].

### **4.2. Messages (Msg)**

Messages are data envelopes. They capture *intent* and *payload*.

* **Standard:** Use Data.define for payloads (e.g., Msg::Resize, Msg::HttpSuccess).  
* **Simple:** Use Symbol for signals (e.g., :quit, :tick).

### **4.3. Commands (Cmd)**

A Command is an object representing a unit of work to be performed later.

* **Interface:** Any object responding to \#call that returns a Msg.  
* **Batteries Included:** The library ships with a standard suite of Commands using **Zero External Dependencies**:  
  * Cmd::Wait.new(seconds, msg)  
  * Cmd::Tick.new(interval, msg)  
  * Cmd::Exec.new(shell\_cmd, on\_exit: MsgClass) (Wraps Open3)  
  * Cmd::NetHttp.get(url, on\_result: MsgClass) (Wraps Net::HTTP)  
  * Cmd::Batch.new(\[cmd1, cmd2\]) (Parallel execution)  
  * Cmd::Sequence.new(\[cmd1, cmd2\]) (Serial execution)

## **5\. Scalability: Fractal Architecture**

To prevent the "God Reducer" problem, the architecture explicitly supports **Composition**.

### **5.1. The Pattern**

Users break their application into sub-modules (e.g., Header, Body). The Main Model holds Sub-Models. The Main Update delegates to Sub-Updates.

### **5.2. Cmd\#map**

To make composition possible, Cmd must support mapping. If a child component returns a Cmd that produces a ChildMsg, the parent must wrap that in a ParentMsg so it knows where to route it when it returns.

Ruby

\# Canonical Implementation of Cmd\#map  
class Cmd  
  def map(\&block)  
    \# Returns a new Cmd that runs the original job,   
    \# then applies the block to the result (Msg).  
    Cmd.new do  
      original\_msg \= self.call  
      block.call(original\_msg)  
    end  
  end  
end

## **6\. Interoperability & Forward Compatibility**

### **6.1. The Glimmer Hook**

Although Glimmer DSL support is slated for Gem 2.0, Gem 1.25 reserves the protocol now.

* **Protocol:** RatatuiRuby::TEA::Msg::FieldUpdated \= Data.define(:field, :value)  
* **Usage:** Future DSLs will use this message to signal user input on form fields, allowing "Dispatch-on-Bind" behavior compatible with immutable models.

### **6.2. Component Isolation**

ratatui\_ruby-tea is strictly distinct from ratatui\_ruby-components. Mixing them is forbidden. This ensures the purity of the TEA runtime remains unpolluted by retained-mode state management issues.

## **7\. Developer Experience (DX)**

We support two distinct coding styles ("Flavors") to capture the full market.

### **Flavor A: The "Script" (Functional)**

*Target: Frontend converts, Quick tools.*

Ruby

RatatuiRuby::TEA::Program.new(  
  model: { count: 0 },  
  update: \-\>(msg, model) {  
    case msg  
    when :inc then \[{count: model\[:count\] \+ 1}, nil\]  
    when :quit then \[model, :quit\]  
    end  
  },  
  view: \-\>(model) { RatatuiRuby::Paragraph.new(text: model\[:count\].to\_s) }  
).run

### **Flavor B: The "Service" (Structured)**

*Target: Rubyists requiring organization.*

Ruby

\# app/update.rb  
class MainUpdate  
  def call(msg, model)  
    \# Logic utilizing service objects and Fractal delegation  
  end  
end

\# app/view.rb  
class MainView  
  def call(model)  
    \# Logic generating Layouts  
  end  
end

RatatuiRuby::TEA::Program.new(  
  model: InitialState.new,  
  update: MainUpdate.new,  
  view: MainView.new  
).run

## **8\. Implementation Checklist (The "Definition of Done")**

1. **Blocker Resolution:** Ensure ratatui\_ruby (Gem 1\) ships poll\_event(timeout: Float).  
2. **Runtime:** Implement Program class with the "Fast Loop" and Thread Pool.  
3. **Safety:** Implement Ractor.make\_shareable validation in initialize (toggleable via config).  
4. **Batteries:** Implement Cmd::Exec, Cmd::NetHttp, Cmd::Batch, Cmd::Sequence.  
5. **Scaling:** Implement Cmd\#map.  
6. **Protocol:** Define RatatuiRuby::TEA::Msg::FieldUpdated.  
7. **Documentation:** Write the README focusing on "Sync Logic, Async Work" and providing examples of both Flavor A and Flavor B.

---

Signed:  
The Internal Architect (Chairman)  
The Technical Writer (Editor)  
Approved by The Council of Architects