<!--
  SPDX-FileCopyrightText: 2026 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

# **RatatuiRuby Ecosystem: Architecture, Vision, and Direction (v2.0)**

Date: December 2025  
Status: Approved by Leadership  
Context: Builds upon ratatui\_ruby v0.3 (Gem 1\) and the Phase 26/27 status.

## ---

**1\. Executive Summary: "The Big Tent" Architecture**

To maximize adoption and solve the "Expression Problem" for Terminal User Interfaces (TUIs), the RatatuiRuby ecosystem will bifurcate after the foundational layer. We are moving from a linear stack to a **Forked Path** architecture.  
This strategy allows us to capture two distinct developer demographics without compromising the ergonomics of either:

1. **The Functional Path (TEA):** For CLI tools, state machines, and developers migrating from Go (Bubble Tea) or Elm. Optimized for **Control and Flow**.  
2. **The Object-Oriented Path (Components):** For dashboards, complex enterprise applications, and "Rails-native" developers. Optimized for **Velocity and Structure**.

Both paths share the same engine (ratatui\_ruby) and eventually the same DSL (glimmer-dsl-ratatui), but they offer mutually exclusive paradigms for managing application state.

## ---

**2\. Gem 1: The Engine (ratatui\_ruby)**

**Role:** The stateless, immediate-mode renderer and event poller.

### **Critical Architectural Change (The Blocker)**

To support the Functional Path (TEA), the engine must support non-blocking execution.

* **Current State:** RatatuiRuby.poll\_event blocks indefinitely until input is received.  
* **Required Change:** The Rust extension (src/events.rs) must be modified to expose crossterm::event::poll with a **timeout**.  
* **New API:** RatatuiRuby.poll\_event(timeout: Float) (e.g., 0.1).  
  * If nil: Block forever.  
  * If 0.0: Non-blocking check.  
  * If \> 0.0: Block for $N$ seconds, return nil if no event.

**Status:** P0 Priority. TEA cannot function without this.

## ---

**3\. Gem 1.25: The Functional Runtime (ratatui\_ruby-tea)**

**Role:** A lightweight, "batteries-included" implementation of The Elm Architecture (TEA).

### **Core Concepts**

* **Naming:** ratatui\_ruby-tea (Namespace: RatatuiRuby::TEA).  
* **Architecture:** The classic triad of Model (State), View (Function), and Update (Logic).  
* **API Design:**  
  * **No Base Classes:** We will **not** require users to inherit from a TEA::App class.  
  * **Callable Objects:** The Program initializer accepts any object that responds to \#call (Procs, Lambdas, or stateless Service Objects). This enables dependency injection and simpler testing.  
  * **Fractal Architecture:** To prevent the "God Reducer" problem (monolithic case statements), documentation will emphasize breaking the Model and Update functions into composable slices (e.g., HeaderUpdate.call(msg, model.header)).

### **Runtime & Concurrency (The "Trojan Horse" Strategy)**

* **v1.x Implementation:** The runtime will use standard Ruby Thread and Queue classes to manage background Commands (Cmd).  
* **Future-Proofing (Ractors):** We intend to switch the engine to Ractors in v2.0 for true parallelism. To ensure user code is ready without a rewrite:  
  * **Enforcement:** The runtime will enforce that all Model and Msg objects are **Ractor-shareable** (frozen/immutable).  
  * **Validation:** In development mode, the runtime will attempt Ractor.make\_shareable(msg) and raise an error if it fails (e.g., if a message contains a mutable String).  
* **Transition:** Users write thread-safe code today; we swap the engine to Ractors transparently in the future.

### **Batteries Included Strategy**

We serve both the "Script Scripter" (who wants zero config) and the "Enterprise Dev" (who needs compliance).

1. **Core Commands:** Cmd.wait (timers), Cmd.tick (animation loops), and Cmd.exec (shell) will be built-in using Ruby Standard Library.  
2. **HTTP Strategy:**  
   * **Built-in:** RatatuiRuby::TEA::Cmd::NetHttp (wrapping Net::HTTP) ships with the gem for zero-dependency fetching.  
   * **Ecosystem:** We will publish a reference implementation/gem (e.g., ratatui\_ruby-tea-httpx) demonstrating how to wrap external clients.  
   * **Contract:** Both implementations adhere to a generic Cmd.call interface, allowing users to swap them or bring their own secured clients.

## ---

**4\. Gem 1.5: The Component Kit (ratatui\_ruby-components)**

**Role:** A stateful, retained-mode component system.

* **Philosophy:** Encapsulated state. Similar to React Class Components or desktop GUI widgets.  
* **Target:** Complex UI trees where identifying specific widgets (Hit Testing) and routing events (Focus Management) is required.  
* **Relationship to TEA:** Mutually exclusive. You generally do not mix a TEA loop with a Component tree.

## ---

**5\. Gem 2: The Syntax (glimmer-dsl-ratatui)**

**Role:** A declarative DSL for generating UI trees.

### **Naming Strategy**

* **Name:** glimmer-dsl-ratatui.  
* **Rationale:** Follows Glimmer ecosystem convention (auto-discovery) and emphasizes the "Ratatui" brand.  
* **Gem Description:** Must explicitly state it is an "unofficial adapter" to respect the Glimmer author's namespace.

### **The "Dual Support" Decision**

This DSL will support **BOTH** architectural paths.

1. **For Components:** Standard Glimmer behavior. Declarative syntax \+ Bi-directional Data Binding (\<=) \+ Listeners.  
2. **For TEA:**  
   * **View Generation:** Used as syntax sugar to generate the Layout tree inside the pure view function.  
   * **Data Binding (The "Sugar for Dispatch"):** We will support \<={ syntax in TEA *if* it follows a specific convention.  
     * *Write:* Instead of mutating the object, the binding will dispatch a standardized Msg (e.g., Msg::FieldUpdated) to the Update loop.  
   * **Restriction:** Documentation must clearly state that standard mutation binding is forbidden in TEA apps.

## ---

**6\. Positioning & Messaging**

We have identified four specific "Marketing Angles" to sell this ecosystem to different personas.

1. **High Control vs. High Velocity:**  
   * TEA is "High Control" (Predictable, Explicit).  
   * Components are "High Velocity" (Composable, encapsulated).  
2. **The "Omakase" Pitch (Targeting Rails Devs):**  
   * Pitch TEA not as "Functional Programming" (scary), but as **"The Standard Architecture."**  
   * Model \= Database in RAM.  
   * Update \= Controller Actions.  
   * View \= ERB Templates.  
   * "Don't reinvent the loop. Use the standard structure."  
3. **The Polyglot Pitch:**  
   * "Solves the Expression Problem." Use TEA for event-driven tools (CLI). Use Components for object-oriented platforms (Dashboards).  
4. **The "Components" Upsell:**  
   * Using TEA but drowning in a massive case statement? The upgrade path is **Components**, which offer modularity and encapsulation.

## ---

**7\. Execution Strategy & Priorities**

We will execute in a **Serial, Onion-Peel** fashion to maintain shipping velocity and avoid "Big Bang" integration risks.  
**Priorities (Ordered):**

1. **Gem 1 Update (The Blocker):** Implement poll\_event(timeout:) in Rust.  
2. **Gem 1.25 (TEA Core):** Build the Runtime Program class (Thread/Queue/Callable Object).  
3. **Gem 1.25 (TEA Batteries):** Implement Core Commands and the Net::HTTP wrapper.  
4. **Gem 1.5 (Components Beta):** Ship the Component base class and Focus Manager. Support *only* Custom Components initially (no built-in widget library yet).  
5. **Gem 2 (Glimmer Beta):** Ship glimmer-dsl-ratatui supporting:  
   * TEA Views (Unidirectional).  
   * Custom Components (Unidirectional).  
6. **Gem 2 (Glimmer Update):** Add Bi-directional binding support (Conventional Dispatch for TEA, Mutation for Components).  
7. **Iterative Expansion:**  
   * Add one built-in Component (wrapping a Ratatui primitive).  
   * Add Glimmer support for that Component.  
   * Repeat until parity is reached.  
8. **Gem 3 (Trails):** Framework development (Future).

---

**Summary:** We are building a high-performance, polyglot-friendly TUI ecosystem that respects Ruby's OO roots while embracing the modern "Elm Architecture" trend. We differentiate through superior ergonomics, robust "batteries," and a clear migration path from simple scripts to enterprise platforms.