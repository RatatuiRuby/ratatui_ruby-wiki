<!--
  SPDX-FileCopyrightText: 2026 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

Here is the unified **Ecosystem Strategy** document. It merges the "Big Tent" strategy with the "Jujube Redux" specification and the "Frame API" reality.  
This document serves as the constitution for the project. It uses standard plain language. It favors short sentences. It assumes intelligence but not prior knowledge of our specific internal debates.

# ---

**The RatatuiRuby Ecosystem Strategy**

**Version:** 1.0  
**Status:** Active  
**Scope:** Universal

## ---

**Introduction: The Big Tent**

**What’s in this Introduction**

* **The Mission:** Why we exist (Native Ruby TUI).  
* **The Problem:** The divide between Object-Oriented and Functional programming.  
* **The Solution:** The "Forked Path" architecture.  
* **The Metaphor:** The Engine, The Runtime, and The Kit.

Summary  
We are building the universal runtime for Ruby terminal interfaces.  
Historically, developers had to choose between tools that matched their philosophy or tools that had performance. If they wanted the Elm Architecture, they used Go (Bubble Tea). If they wanted raw speed, they used Rust (Ratatui). If they wanted Ruby, they accepted slow rendering or confusing C-extensions.  
We reject this choice.  
We have built a high-performance Engine in Rust. On top of it, we support two distinct architectural paths. **Path A (The Runtime)** is for functional programmers who view an application as a state machine. **Path B (The Kit)** is for object-oriented developers who view an application as a hierarchy of stateful components. Both paths run on the same metal. Both share the same rendering capabilities. We do not force a paradigm. We provide a Big Tent.

## ---

**Chapter 1: The Engine (ratatui\_ruby)**

**What’s in this Chapter**

* **Context:** The foundation of the ecosystem.  
* **The Architecture:** A stateless, immediate-mode wrapper around the Rust ratatui crate.  
* **The Frame API:** The solution to layout and hit-testing (formerly "Proposal 3").  
* **The Primitives:** Text measurement, cursor control, and event polling.  
* **Constraint:** This layer is unopinionated. It draws what it is told.

Summary  
The Engine is the metal. It has no concept of a "Button" or a "Form." It knows only geometry and events.  
Its primary interface is the Frame. The Engine yields a Frame object to the developer. The developer tells the Frame exactly where to render a widget. This solves the "hit-testing" problem that plagues immediate-mode GUIs. The developer calculates the layout once, draws to those coordinates, and saves them. When the user clicks the mouse, the developer checks those saved coordinates.  
The Engine is complete. It handles the heavy lifting: Unicode width calculations, buffer diffing, and terminal rendering. It is thread-safe. It is fast. It is the bedrock upon which the rest of the ecosystem stands.

## ---

**Chapter 2: The Fork in the Road**

**What’s in this Chapter**

* **Context:** Developers have fundamentally different mental models for UI.  
* **Problem:** Forcing an OO developer to use Reducers is painful. Forcing an FP developer to use Classes is painful.  
* **Solution:** We split the ecosystem into two mutually exclusive Layer 2 libraries.  
* **Path A:** ratatui\_ruby-tea (The Runtime). "Data In, Data Out."  
* **Path B:** ratatui\_ruby-components (The Kit). "Objects communicating."

Summary  
After the Engine, the path diverges. You cannot mix these paths.  
Choose **Path A** if you are building a CLI tool, a wizard, or a highly controlled state machine. It is strict. It is predictable. It uses the Elm Architecture.  
Choose **Path B** if you are building a dashboard, an enterprise platform, or a complex desktop-like application. It is flexible. It allows for encapsulation. It uses the Component pattern familiar to React or Rails developers.  
We support both equally. We optimize both for the Ruby 4.0 era.

## ---

**Chapter 3: Path A \- The Runtime (ratatui\_ruby-tea)**

**What’s in this Chapter**

* **Philosophy:** "Just Ruby." No base classes. No complex inheritance.  
* **Architecture:** The Elm Architecture (Model-View-Update).  
* **The Interface:** Callable Objects (Procs/Lambdas). TEA.run(model:, update:, view:).  
* **Concurrency:** "Sync Logic, Async Work." The main thread renders; worker threads execute commands.  
* **Safety:** The "Trojan Horse." We enforce Ractor-safety (deep freezing) now, so we can swap threads for Ractors later without breaking user code.  
* **Scale:** Fractal Architecture. Composition of update functions preventing monolithic case statements.

Summary  
The Runtime is a functional layer. It treats your application as a pure function.  
We rejected the "Framework" approach of inheriting from a base class. Instead, we use Ruby's native strengths: Procs and Arrays. A Command is just a Proc that returns a message. A Batch is just an Array of Procs. This makes the runtime incredibly thin and easy to test.  
We enforce strict discipline. You cannot pass mutable objects in messages. This constraint ensures that your application is ready for the parallel future of Ruby (Ractors). The Runtime manages the loop. It polls for events. It manages the worker pool. You simply define how data transforms into a view.

## ---

**Chapter 4: Path B \- The Kit (ratatui\_ruby-components)**

**What’s in this Chapter**

* **Philosophy:** Encapsulation and State.  
* **Architecture:** Retained-mode components on an immediate-mode engine.  
* **The Component Class:** render(frame, area) and handle\_event(event).  
* **The Lifecycle:** The "Reconciliation" loop.  
* **Focus Management:** Automatic tabbing and keyboard routing.

Summary  
The Kit restores the Object-Oriented model.  
In immediate-mode, widgets forget everything the moment they are drawn. The Kit gives them memory. A Button object remembers it is hovered. An Input object remembers its text.  
The Kit uses the Engine's Frame API directly. Each component is responsible for rendering itself into a specific area provided by its parent. This encapsulates layout logic. A parent component does not need to know how a child draws itself; it only needs to allocate space for it. This path allows for large, distributed teams to build complex UIs where no single developer needs to understand the entire state tree.

## ---

**Chapter 5: The Syntax (glimmer-dsl-ratatui)**

**What’s in this Chapter**

* **Context:** Writing nested object initialization code is verbose.  
* **Problem:** UI structure is hierarchical, but Ruby code is linear.  
* **Solution:** A declarative Domain Specific Language (DSL).  
* **Compatibility:** Works as a view layer for *both* Path A and Path B.  
* **Constraint:** Bi-directional data binding works only in Path B.

Summary  
The Syntax is sugar. It makes the code look like the UI.  
Instead of manually instantiating classes and passing arrays of children, you use blocks. You write vertical\_layout { button { ... } }.  
The Syntax adapts to the path you chose. If you are using **The Runtime (Path A)**, the DSL generates the purely functional view tree required by the render loop. If you are using **The Kit (Path B)**, the DSL instantiates and configures your stateful component objects. It is the unifying layer that makes RatatuiRuby feel native to the language.

## ---

**Chapter 6: The Framework (ratatui\_ruby-trails)**

**What’s in this Chapter**

* **Context:** Libraries are not enough for enterprise applications.  
* **Problem:** Developers waste time reinventing folder structures, database connections, and configuration loaders.  
* **Solution:** A "Rails-like" framework for TUIs.  
* **Architecture:** MVC (Model-View-Controller).  
* **Integration:** Active Record, Zeitwerk, and standard configuration.

Summary  
The Framework is the end state. It is "Omakase"—the chef's choice.  
It assumes you are using **The Kit (Path B)**. It assumes you want a database. It generates your file structure. It wires your models to your views. It manages your application lifecycle. It is for developers who want to build a product, not a UI pipeline. It turns RatatuiRuby from a library into a platform.

## ---

**Chapter 7: Execution & Roadmap**

**What’s in this Chapter**

* **Strategy:** The "Onion Peel." We build layers from the inside out.  
* **Phase 1:** The Engine (Complete).  
* **Phase 2:** The Runtime (Next). Low effort, high impact. Captures the functional market.  
* **Phase 3:** The Kit. High effort. Captures the enterprise market.  
* **Phase 4:** The Syntax. High reward. Improves developer experience for everyone.  
* **Phase 5:** The Framework. Long term. cements the ecosystem.

Summary  
We do not build in parallel. We build serially.  
We have finished the Engine. We are now building the Runtime. This ensures that every release is usable. We do not ship "alpha" frameworks that rely on "beta" engines. We stabilize the foundation before we raise the walls.  
This strategy minimizes risk. If we stop after Phase 2, we still have the best TUI engine and the best TEA runtime in Ruby. Every step provides value. We are building for the next decade of Ruby development.