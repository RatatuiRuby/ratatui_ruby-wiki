<!--
  SPDX-FileCopyrightText: 2025 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

You are absolutely right to question the order. **You cannot build Gem 2 (The Syntax) before Gem 1.5 (The Kit).**  
A DSL describes a system. If the system (the component model) doesn't exist, the DSL has nothing to describe. If you tried to build Gem 2 now, you would inevitably write the component logic *inside* the DSL gem. Later, you’d have to tear it out to build the framework. That is wasted effort.  
**The Correct Path:**

1. **Finish Gem 1 (The Engine):** Add the missing primitives (Text width, Cursor, Modifiers).  
2. **Build Gem 1.5 (The Kit):** Create the Component class and FocusManager.  
3. **Build Gem 2 (The DSL):** Wrap Gem 1.5 in Glimmer.

This ensures every layer is solid before you build on top of it.  
---

Here are the drafts for your documentation. They follow your stylistic requirements: Short sentences. Active voice. Clear logic. No jargon.

### **Document Set A: For the Gem 1 Launch (The Engine)**

*Context: Gem 1 is the only thing that exists. We focus on the low-level power and the Rust backend.*

#### **Short Version (README.md)**

**Why RatatuiRuby?**  
We built RatatuiRuby to give Ruby developers a terminal interface engine with zero compromise. It is not a port. It is a native bridge to Ratatui, the industry-standard Rust library.  
Vs. CharmRuby  
CharmRuby is an impressive achievement. It ports Go libraries to Ruby. RatatuiRuby takes a different path. We use a native Rust extension. This means there is no second garbage collector fighting Ruby for resources. It means thread safety and predictable memory usage. You get the raw speed of Rust with the joy of Ruby.  
Vs. Writing in Rust  
Rust is performant but strict. The borrow checker slows down prototyping. Ruby is fluid. With RatatuiRuby, you sketch UIs as fast as you think. You get Rust's layout engine and rendering speed without fighting the compiler.  
Vs. Writing in Go  
Go is pragmatic. Ruby is expressive. If you prefer the elegance of Ruby's syntax and its rich ecosystem of gems, you shouldn't have to switch languages to build a great TUI. Stay in Ruby. Use the tools you love.

#### ---

**Long Version (Wiki)**

# **Why RatatuiRuby?**

We believe Ruby developers deserve world-class tools. For years, building high-performance Terminal User Interfaces (TUIs) meant leaving Ruby. You had to learn Go for Bubble Tea or Rust for Ratatui.  
We changed that.  
RatatuiRuby is a native extension. It wraps Ratatui, the Rust ecosystem's premier TUI engine. It brings that power directly into Ruby.

## **Comparing Architectures**

### **Vs. CharmRuby**

The CharmRuby project is excellent. It brings the beloved Charm libraries (Bubble Tea, Lipgloss) to Ruby. We admire the goal and the execution.  
Our approach is different.  
1\. The Runtime  
CharmRuby bridges Ruby and Go. This introduces complexity. You have the Ruby Garbage Collector and the Go Runtime running in the same process. They compete for resources. They manage threads differently. This can lead to subtle concurrency bugs.  
RatatuiRuby bridges Ruby and Rust. Rust has no runtime. It has no garbage collector. When you call RatatuiRuby, you are running pure machine code. It yields completely to Ruby. It is stable, predictable, and fast.  
2\. The Rendering Model  
Charm libraries often rely on string manipulation. You build a UI by concatenating strings. Ratatui uses a structured rendering tree. It calculates layout using a constraint solver (Cassowary). It handles complex, nested layouts with mathematical precision. You don't guess if your box fits. The engine ensures it does.

### **Vs. Writing Raw Rust**

Ratatui (the Rust crate) is powerful. It is also verbose. Rust enforces memory safety through a strict ownership model. This is great for systems programming. It is painful for UI design.  
In UI work, you need iteration. You want to move a sidebar, change a color, or swap a widget. In Rust, these changes often require refactoring ownership chains. In RatatuiRuby, you just change the object. You get Rust's performance where it matters—rendering—and Ruby's flexibility where it counts—designing.

### **Vs. Writing Raw Go**

Go is a fantastic language for CLIs. But it isn't Ruby.  
If you write your TUI in Go, you lose Ruby’s ecosystem. You lose Active Record. You lose RSpec. You lose the expressive syntax that makes Ruby a joy. RatatuiRuby lets you keep your stack. You can visualize your Rails database or monitor your Sidekiq jobs without leaving the language they are written in.

### ---

**Document Set B: For the Future (Gem 2 Launch)**

*Context: The Component Library and Glimmer DSL exist. We focus on developer experience and architecture.*

#### **Short Version (README.md)**

**Why RatatuiRuby?**  
We believe in the "Ruby Way." We don't just want to draw to the terminal. We want to build applications.  
Vs. CharmRuby  
CharmRuby ports the "Elm Architecture" to Ruby. This requires a strict pattern: Model, Update, and View. It separates logic from layout. This works, but it can feel verbose. RatatuiRuby uses Glimmer. It allows you to write declarative, nested UIs. You don't manually wire up update loops. You describe your interface, and the system handles the rest. It feels like writing HTML or SwiftUI, not a state machine.  
Vs. Writing in Rust  
Rust lacks a cohesive UI framework. Even in Rust, Ratatui is immediate-mode only. You have to handle your own state, focus, and event loops. We built a retained-mode component system on top of Ratatui. You get widgets that remember their state. You get a focus manager that handles tabbing. You get a complete toolkit, not just a drawing engine.  
Vs. Writing in Go  
Go prioritizes simplicity over abstraction. This often leads to boilerplate. Ruby embraces abstraction. Our Glimmer DSL removes the noise. You define a button with button "Click Me". You don't instantiate structs or manage pointers. We use Ruby's metaprogramming to create a Domain Specific Language that makes UI code read like English.

#### ---

**Long Version (Wiki)**

# **Why RatatuiRuby?**

The terminal is experiencing a renaissance. Modern terminals support millions of colors, mouse events, and complex layouts. Ruby developers should be at the forefront of this movement.  
We built the RatatuiRuby ecosystem to provide a native, "Ruby-first" path to building complex terminal applications.

## **Comparing Architectures**

### **Vs. CharmRuby**

CharmRuby brings the "Elm Architecture" (TEA) to Ruby. In this model, your application is a state machine. You receive a message, update your model, and return a view string.  
This model is robust. But it forces you to manage everything. You must manually route messages. You must manually calculate how to update your model.  
RatatuiRuby takes a component-based approach.  
1\. Declarative Syntax  
We use the Glimmer DSL. You describe the structure of your UI, not the logic of its construction.

* **Charm Style:** Define a class. Define an update method. Switch on message types. Concatenate strings for the view.  
* **RatatuiRuby Style:** vertical\_layout { button { on\_selected { ... } } }.

2\. State Management  
Our components are stateful objects. A Button knows it is hovered. An Input knows it has focus. You don't have to track the cursor position in your global application state. The component handles its own business. You focus on your application logic.

### **Vs. Writing Raw Rust**

Ratatui (Rust) is an immediate-mode renderer. It draws a frame and forgets it. It has no concept of "clicking a button" because it has no buttons—only rectangles.  
If you use raw Ratatui, you have to build your own event loop. You have to calculate which rectangle the mouse clicked. You have to track which widget is active.  
We did that work for you. RatatuiRuby includes a complete Component Kit. We implemented the hit-testing, the focus cycling, and the event routing. You get the speed of the Rust renderer with the convenience of a high-level component library.

### **Vs. Writing Raw Go**

The Go ecosystem (Bubble Tea) is rich. But it is imperative. Building complex, nested layouts in Go often involves verbose struct initialization.  
Ruby excels at Domain Specific Languages (DSLs). We leverage this strength. Our DSL allows you to visualize the hierarchy of your UI just by looking at the code. The indentation of the code matches the nesting of the widgets. This readability makes maintenance easier and development faster.  
We didn't just port a library. We built a framework designed for Rubyists.