<!--
  SPDX-FileCopyrightText: 2025 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

# **Proposal Codename “Banana”**

This is a smart naming convention. Using ratatui\_ruby- as the prefix keeps the namespace clean (RatatuiRuby::TEA, RatatuiRuby::Components) and makes finding related gems easier.  
For Gem 2, note that the Glimmer ecosystem usually prefers glimmer-dsl-name (e.g., glimmer-dsl-libui), but ratatui\_ruby-glimmer\_dsl is perfectly valid and keeps your "brand" consistent. We will proceed with your naming scheme.  
Here are the two documents: the **Revised Ecosystem Architecture** (incorporating the "Big Split") and the **Detailed Design Doc for Gem 1.25**.

# ---

**Document 1: The RatatuiRuby Ecosystem Architecture (v2.0)**

## **1\. High-Level Architecture: The "Big Tent"**

The RatatuiRuby ecosystem is no longer a single vertical stack. It is a **Platform** with two distinct development paths. Both paths share the same high-performance engine (Gem 1), but offer different paradigms for application state and logic.

| Layer | The Shared Foundation |
| :---- | :---- |
| **Level 1** | **ratatui\_ruby (The Engine)** Rust-based Renderer, Layout Solver, Event Polling, Primitive Shapes. |

### ---

**The Two Paths**

After Level 1, the developer chooses their paradigm:

| Feature | Path A: The Functional Track | Path B: The Object-Oriented Track |
| :---- | :---- | :---- |
| **Paradigm** | **The Elm Architecture (TEA)** | **Component-Based (Retained Mode)** |
| **Primary Gem** | **Gem 1.25: ratatui\_ruby-tea** | **Gem 1.5: ratatui\_ruby-components** |
| **State** | Single immutable\* global Model. | Distributed mutable state in Component objects. |
| **Logic** | Pure update(msg, model) function. | Event handlers (on\_click) in classes. |
| **View** | Pure view(model) function returns tree. | view method returns local tree for that component. |
| **Extensions** | None needed (Pattern is self-contained). | **Gem 2:** ratatui\_ruby-glimmer\_dsl (Syntax) **Gem 3:** ratatui\_ruby-trails (Framework) |
| **Target User** | FP enthusiasts, CLI tool builders, Go/BubbleTea converts. | Rails developers, Desktop GUI (Qt/SWT) developers. |

## ---

**2\. Layer Integration Details**

### **How Gem 1.25 (ratatui\_ruby-tea) fits**

* **Dependency:** Directly depends on ratatui\_ruby.  
* **Interaction:** It implements a **Standard Loop** that calls RatatuiRuby.draw and RatatuiRuby.poll\_event.  
* **Isolation:** It is a "dead end" architecturally. You do not build Glimmer or Trails on top of it. It is a lightweight alternative for users who want "Simple & Fast" without the weight of a component lifecycle.

### **How Gem 1.5 (ratatui\_ruby-components) fits**

* **Dependency:** Directly depends on ratatui\_ruby.  
* **Interaction:** It abstracts the draw call. It introduces a FocusManager and Component lifecycle (mount/unmount) that Gem 1 does not possess.  
* **Foundation:** It serves as the backing store for Gem 2\.

### **How Gem 2 (ratatui\_ruby-glimmer\_dsl) fits**

* **Dependency:** Depends on ratatui\_ruby-components.  
* **Interaction:** It provides a DSL that instantiates Gem 1.5 classes. It does **not** talk to Gem 1 directly.

# ---

**Document 2: Design Document \- Gem 1.25 (ratatui\_ruby-tea)**

Package Name: ratatui\_ruby-tea  
Namespace: RatatuiRuby::TEA  
Goal: Provide the "Elm Architecture" (Model-View-Update) pattern using RatatuiRuby as the runtime.

## **1\. Core Concepts**

The library imposes a strict loop:

1. **Model:** The application state.  
2. **View:** A function transforming State \-\> Layer 1 Render Tree.  
3. **Update:** A function transforming (Msg, State) \-\> (NewState, Cmd).  
4. **Cmd:** A side-effect (e.g., "Wait 1 second", "Read File") that returns a Msg asynchronously.

## **2\. The Program Class**

This is the entry point. It manages the loop.

Ruby

module RatatuiRuby  
  module TEA  
    class Program  
      \# @param model \[Object\] Initial state  
      \# @param update \[Proc\] (Msg, Model) \-\> \[Model, Cmd\]  
      \# @param view \[Proc\] (Model) \-\> RatatuiRuby::Widget (usually a Layout)  
      \# @param subscriptions \[Proc\] (Model) \-\> Cmd (optional, for event listening)  
      def initialize(model:, update:, view:, subscriptions: nil)  
        @model \= model  
        @update \= update  
        @view \= view  
      end

      def run  
        RatatuiRuby.run do  
          loop do  
            \# 1\. Render Phase  
            render\_tree \= @view.call(@model)  
            RatatuiRuby.draw(render\_tree)

            \# 2\. Input Phase  
            \# We block here waiting for input OR a Cmd to finish  
            \# (Note: Requires concurrent handling for Cmds in v2,   
            \# for v1 we might just handle keyboard events synchronously)  
            event \= RatatuiRuby.poll\_event  
              
            \# 3\. Message Transformation  
            msg \= convert\_event\_to\_msg(event)  
              
            \# 4\. Update Phase  
            @model, cmd \= @update.call(msg, @model)  
              
            \# 5\. Command Execution (Side Effects)  
            handle\_cmd(cmd) if cmd

            break if cmd \== :quit  
          end  
        end  
      end  
    end  
  end  
end

## **3\. The Msg Protocol**

Unlike Go (which uses structs/interfaces) or Elm (which uses ADTs), Ruby uses **Symbols** or **Data Classes** for messages.  
**Recommended Pattern:**

Ruby

\# Simple  
:increment  
:decrement

\# Complex (Data.define)  
UserTyped \= Data.define(:text)  
WindowResized \= Data.define(:width, :height)

## **4\. The Cmd Architecture**

Side effects must be managed carefully. A Cmd is essentially a Proc that runs *outside* the render loop and eventually feeds a Msg back into the loop.

* **Synchronous Cmds (v1):** The Program executes them immediately before the next render.  
* **Asynchronous Cmds (v2):** Required for things like "HTTP Request". Requires a Thread or Fiber that sends the result back to the main loop via a thread-safe Queue.

**Design Decision for v0.1:** Start with **Synchronous-only** (except for UI events).

## **5\. Usage Example (The "Counter" App)**

This is how the end-user code looks. It is functionally identical to Bubble Tea, but cleaner.

Ruby

require 'ratatui\_ruby/tea'

\# 1\. The Model  
Model \= Data.define(:count)

\# 2\. The Update Function  
\# Returns \[NewModel, Cmd\]  
Update \= \-\>(msg, model) do  
  case msg  
  when :increment  
    \[model.with(count: model.count \+ 1), nil\]  
  when :decrement  
    \[model.with(count: model.count \- 1), nil\]  
  when :quit  
    \[model, :quit\]  
  else  
    \[model, nil\]  
  end  
end

\# 3\. The View Function  
\# Returns a Layer 1 Tree  
View \= \-\>(model) do  
  RatatuiRuby::Paragraph.new(  
    text: "Count: \#{model.count}\\nPress \+/- to change, q to quit",  
    block: RatatuiRuby::Block.new(borders: \[:all\], title: "Counter")  
  )  
end

\# 4\. Wiring  
\# Map raw Ratatui events to Msgs  
def map\_input(event)  
  case event\[:code\]  
  when '+' then :increment  
  when '-' then :decrement  
  when 'q' then :quit  
  end  
end

\# 5\. Run  
program \= RatatuiRuby::TEA::Program.new(  
  model: Model.new(count: 0),  
  update: Update,  
  view: View,  
  input\_mapper: method(:map\_input)  
)

program.run

## **6\. Comparison with bubbletea (Go)**

| Feature | bubbletea (Go) | ratatui\_ruby-tea (Ruby) |
| :---- | :---- | :---- |
| **Definition** | Structs satisfying interfaces. | Procs / Lambdas / Duck Typing. |
| **Update** | func (m Model) Update(msg) | Proc.call(msg, model) |
| **View** | Returns string (ANSI codes). | Returns RatatuiRuby::Object tree. |
| **Runtime** | Go Runtime \+ GC. | **Rust Engine** (Zero overhead). |
| **Concurrency** | Goroutines. | Ruby Threads/Fibers (Future). |

## **7\. Strategic Advantages**

1. **Zero Boilerplate:** No explicit class definitions required; Procs work fine.  
2. **Performance:** The "View" phase constructs lightweight Ruby Data objects, which Rust renders instantly. Bubble Tea often relies on string concatenation which generates garbage.  
3. **Familiarity:** It captures the exact semantics of Elm/Redux that functional developers love.