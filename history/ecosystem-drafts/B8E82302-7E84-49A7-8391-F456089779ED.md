<!--
  SPDX-FileCopyrightText: 2026 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

Here is the foundational **Ecosystem Strategy Document** for the RatatuiRuby project.  
This document serves as the "Constitution" for the project. It unifies the technical architecture (Proposal 3), the application patterns (TEA & Components), and the long-term vision. It replaces all previous internal codenames and version numbers with the official gem names.

# ---

**RatatuiRuby Ecosystem Strategy: The Universal TUI Runtime**

Version: 1.0.0 (Constitution)  
Audience: Architects, Product Managers, Staff Engineers, Contributors  
Status: Living Document

## ---

**Chapter 1: Vision & Philosophy**

**What’s in this Chapter:**

* **The "Big Tent" Strategy:** Why we support both Functional (Elm) and Object-Oriented (Rails) paradigms.  
* **Native vs. Ported:** The architectural decision to use Rust FFI instead of wrapping Go/C libraries.  
* **The "Universal Runtime" Concept:** How a single engine (ratatui\_ruby) powers two distinct application architectures.  
* **Market Positioning:** How we compare to CharmRuby (Go port), Native Rust, and Native Go.

Chapter Summary  
We are building the Universal TUI Runtime for Ruby. We believe developers should not have to switch rendering engines to change their coding style.  
Our strategy is the **"Forked Path."** At the bottom, we share a single, high-performance engine (ratatui\_ruby). Above that, we offer two mutually exclusive paths:

1. **Path A (Functional):** ratatui\_ruby-tea. Optimized for CLI tools and state machines. It follows The Elm Architecture.  
2. **Path B (Object-Oriented):** ratatui\_ruby-components. Optimized for complex dashboards and enterprise applications. It follows a Component-based, Retained Mode architecture.

We differentiate ourselves from competitors like CharmRuby through **Architecture** and **Performance**. CharmRuby bridges Ruby and Go, creating runtime contention. We use a native Rust extension with no runtime overhead, giving Ruby developers the raw speed of Rust with the joy of Ruby. We do not choose a side in the "OO vs. Functional" war; we win both.

## ---

**Chapter 2: The Core Engine (ratatui\_ruby)**

**What’s in this Chapter:**

* **Immediate Mode Rendering:** The lifecycle of a frame (Build Tree \-\> Draw \-\> Discard).  
* **The Frame API (Proposal 3):** Why we expose an imperative draw { |frame| ... } block instead of just a declarative tree.  
* **Layout & Hit Testing:** Solving the "Duplication Footgun" by calculating layout and rendering in a single pass.  
* **Primitives:** The essential tools exposed to upper layers (Text Measurement, Cursor Positioning, Event Modifiers).  
* **Rust FFI Architecture:** Thread safety, memory management, and magnus integration.

Chapter Summary  
The Engine (ratatui\_ruby) is the stateless foundation. It wraps the Rust ratatui library. It does not know what a "Button" is; it only knows Rect, Style, and Frame.  
We utilize a **Frame-Based API**. Instead of passing a static tree to the engine, the user provides a block that receives a Frame object. This mirrors the native Rust API. It allows the user to calculate layout, explicitly render widgets into specific areas, and—critically—cache those areas for hit testing in the next event loop. This "Calculate Once, Use Everywhere" pattern eliminates layout duplication errors.  
The Engine is strictly **Immediate Mode**. It retains no state between frames. It provides the raw primitives—Unicode text width calculation, cursor placement, and non-blocking event polling—that the upper layers (TEA and Components) need to build their abstractions.

## ---

**Chapter 3: Path A — The Functional Runtime (ratatui\_ruby-tea)**

**What’s in this Chapter:**

* **The Elm Architecture (TEA):** Model, Update, View.  
* **"Sync Logic, Async Work":** The concurrency model. The Main Thread owns the View/Update (pure logic). Background threads own Commands (side effects).  
* **The "Trojan Horse":** Enforcing Ractor-safety (deep freezing) in v1.0 to prepare for a v2.0 Ractor migration without breaking changes.  
* **Callable Objects:** Rejecting class inheritance in favor of Procs and Lambdas for Update and View logic.  
* **Fractal Architecture:** How to compose large applications using recursive Cmd.map instead of monolithic reducers.

Chapter Summary  
ratatui\_ruby-tea is the runtime for the Functional Path. It follows the philosophy of "Data In, Data Out."  
The runtime guarantees a 60 FPS UI by strictly separating logic from side effects. The **Main Thread** runs a "Fast Loop" that only renders and calculates state changes. **Worker Threads** execute Commands (I/O, Shell, HTTP) and push Messages back to the main loop via a thread-safe queue.  
We enforce strict immutability. In Debug Mode, the runtime checks that all Messages and Models are Ractor.shareable?. If a user passes a mutable object, we crash immediately. This ensures that when Ruby 3.x/4.x Ractors become stable, we can swap the threading model for true parallelism without changing a single line of user code.

## ---

**Chapter 4: Path B — The Component Kit (ratatui\_ruby-components)**

**What’s in this Chapter:**

* **Retained Mode on Immediate Mode:** How stateful Ruby objects generate transient Render Trees.  
* **The Component Lifecycle:** handle\_event \-\> State Mutation \-\> view (Tree Generation).  
* **Focus Management:** The FocusManager singleton, tab cycling, and event routing.  
* **Hit Testing Integration:** How Components use the Engine's Frame API to determine their own bounds for mouse interaction.  
* **The "Missing 4" Usage:** How components use Engine primitives to auto-size themselves and blink the cursor.

Chapter Summary  
ratatui\_ruby-components is the runtime for the Object-Oriented Path. It introduces the concept of Stateful Components.  
Unlike Path A, where state is global, Path B distributes state across a tree of Component objects (e.g., Button, Input). Each Component is responsible for its own logic. The Runtime acts as a "Factory," walking the Component tree every frame and asking each Component to generate a lightweight Layer 1 structure (via the view method) for the Engine to render.  
Crucially, Components handle their own interactivity. They use the Engine's **Frame API** to render themselves into specific Rects. They store these rects internally. When a mouse event occurs, the Runtime asks the Component Tree, "Who owns this pixel?" The Component checks its stored rect and handles the event. This encapsulates the complexity of layout math inside the Component, keeping the application code clean.

## ---

**Chapter 5: The Syntax Layer (glimmer-dsl-ratatui)**

**What’s in this Chapter:**

* **Declarative UI:** Bringing the Glimmer syntax (nested blocks) to the terminal.  
* **The Bridge:** How one DSL powers two architectures.  
* **Unidirectional Binding (Path A):** Using the DSL purely as a View function for TEA.  
* **Bidirectional Binding (Path B):** Using the DSL to wire Component state to the View (e.g., value \<= \[model, :name\]).  
* **Implicit vs. Explicit:** How the DSL abstracts away the manual instantiation of Data objects.

Chapter Summary  
glimmer-dsl-ratatui is the "Skin" of the ecosystem. It provides a declarative, Ruby-native syntax for building UIs.  
The DSL is context-aware.

* **In Path A (TEA):** It acts as a pure transformation function. It takes the immutable Model and outputs the Render Tree. It forbids bidirectional data binding because TEA state flows one way.  
* **In Path B (Components):** It acts as a structure builder. It instantiates Components, nests them in Layouts, and binds their attributes to the parent's state.

This layer allows developers to write visual code visually (vertical\_layout { button }) while the underlying Runtimes (TEA or Components) handle the execution logic.

## ---

**Chapter 6: The Framework (ratatui\_ruby-trails)**

**What’s in this Chapter:**

* **The "Rails" Experience:** Generators, file structure, configuration.  
* **MVC in the Terminal:** Mapping Models (ActiveRecord), Views (Glimmer), and Controllers (Update Logic).  
* **The Application Loop:** Managing the lifecycle of the TUI alongside the database connection and background jobs.  
* **Testing:** Integrated testing patterns for TUI interactions.

Chapter Summary  
ratatui\_ruby-trails is the final layer. It is the "Rails for TUIs."  
It provides the opinionated glue that holds the stack together. It offers a rails new equivalent (trails new) that sets up a project with the correct directory structure, database integration, and testing harness. It chooses defaults for the user, favoring the **Component Path** for large-scale enterprise applications, but supporting the **Functional Path** for complex localized tools. It transforms ratatui\_ruby from a library into a platform.

## ---

**Chapter 7: Execution & Roadmap**

**What’s in this Chapter:**

* **The "Onion Peel" Strategy:** Why we build layers serially (Engine \-\> TEA \-\> Components \-\> DSL \-\> Framework).  
* **Release Dependencies:** Explicit blockers for each phase (e.g., Engine poll\_event blocks TEA).  
* **Marketing Personas:** How to sell the "Big Tent" to Junior Devs, Frontend Devs, Polyglots, and Omakase Rubyists.  
* **Maintenance Policy:** Semantic versioning and the guarantee of "No Dead Ends" (migration paths).

Chapter Summary  
We execute strictly bottom-up. We do not build the DSL until the Components exist. We do not build the Components until the Engine is feature-complete.

1. **Phase 1:** Finalize ratatui\_ruby (Proposal 3 Frame API & Non-blocking Poll).  
2. **Phase 2:** Ship ratatui\_ruby-tea. (Capture the CLI market).  
3. **Phase 3:** Ship ratatui\_ruby-components. (Capture the Enterprise market).  
4. **Phase 4:** Ship glimmer-dsl-ratatui. (Improve Developer Experience).  
5. **Phase 5:** Ship ratatui\_ruby-trails. (Standardize the Ecosystem).

This serial execution ensures that every release is a stable, usable product that validates the layer beneath it. We build on bedrock, not ideas.