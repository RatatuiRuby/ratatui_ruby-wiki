<!--
  SPDX-FileCopyrightText: 2025 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

This is an incredibly strong, cohesive specification. It is idiomatic ("Just Ruby"), future-proof ("Ractor Ready"), and strategically positioned ("The Functional Path").  
I have **one technical refinement** regarding the **Command/Subscription** implementation to avoid a common trap in Ruby concurrency:  
Refinement: The "Publisher" Pattern for Commands  
Your spec defines Cmd as \-\> { return Msg }. This works for "One-Shot" tasks (HTTP request).  
It works poorly for Streams (WebSockets, Timers, File Watchers).

* *Current Spec:* Recursive Commands (Thread starts \-\> sleep \-\> return msg \-\> thread dies \-\> Update \-\> New Thread starts). This creates unnecessary thread churn.  
* *Adjustment:* Define Cmd as \-\>(publish) { ... }.  
  * **One-Shot:** \-\>(publish) { result \= http.get; publish.call(result) }  
  * **Stream:** \-\>(publish) { loop { sleep 1; publish.call(:tick) } }  
  * This allows a single Thread to stay alive and emit multiple events, solving the "Subscription" problem without extra architecture.

Other than that, the spec is effectively perfect for v1.0.  
Here is your requested **"Why RatatuiRuby?"** documentation in the two versions you asked for, plus a master **ECOSYSTEM.md** to carry context forward.

### ---

**Document Set A: For the Gem 1 Launch (The Engine)**

*(Context: Only ratatui\_ruby exists. Focus on Engine power.)*

#### **Short Version (README.md)**

**Why RatatuiRuby?**  
We built RatatuiRuby to give Ruby developers a terminal interface engine with zero compromise. It is not a port; it is a native bridge to Ratatui, the industry-standard Rust library.  
Vs. CharmRuby  
CharmRuby is an impressive achievement that ports Go libraries to Ruby. RatatuiRuby takes a different path. We use a native Rust extension via Magnus. This means there is no second garbage collector (Go Runtime) fighting Ruby for resources. It means true thread safety and predictable memory usage. You get the raw speed of Rust with the joy of Ruby.  
Vs. Writing in Rust  
Rust is performant but strict. The borrow checker slows down prototyping. Ruby is fluid. With RatatuiRuby, you sketch UIs as fast as you think. You get Rust's layout engine and rendering speed without fighting the compiler.  
Vs. Writing in Go  
Go is pragmatic. Ruby is expressive. If you prefer the elegance of Ruby's syntax and its rich ecosystem of gems, you shouldn't have to switch languages to build a great TUI. Stay in Ruby. Use the tools you love.

#### **Long Version (Wiki)**

# **Why RatatuiRuby?**

We believe Ruby developers deserve world-class tools. For years, building high-performance Terminal User Interfaces (TUIs) meant leaving Ruby. You had to learn Go for Bubble Tea or Rust for Ratatui. We changed that.  
RatatuiRuby is a native extension. It wraps Ratatui, the Rust ecosystem's premier TUI engine, bringing that power directly into Ruby.

## **Comparing Architectures**

### **Vs. CharmRuby**

The CharmRuby project is excellent. It brings the beloved Charm libraries (Bubble Tea, Lipgloss) to Ruby. We admire the goal and the execution. Our approach is different.  
1\. The Runtime  
CharmRuby bridges Ruby and Go. This introduces complexity. You have the Ruby Garbage Collector and the Go Runtime running in the same process. They compete for resources and manage threads differently, which can lead to subtle concurrency bugs or overhead.  
RatatuiRuby bridges Ruby and Rust. Rust has no runtime and no garbage collector. When you call RatatuiRuby, you are running pure machine code. It yields completely to Ruby. It is stable, predictable, and fast.  
2\. The Rendering Model  
Charm libraries often rely on string manipulation, building UIs by concatenating strings. Ratatui uses a structured rendering tree. It calculates layout using a constraint solver (Cassowary). It handles complex, nested layouts with mathematical precision. You don't guess if your box fits; the engine ensures it does.

### **Vs. Writing Raw Rust**

Ratatui (the Rust crate) is powerful but verbose. Rust enforces memory safety through a strict ownership model. This is great for systems programming but painful for UI design.  
In UI work, you need iteration. You want to move a sidebar, change a color, or swap a widget. In Rust, these changes often require refactoring ownership chains. In RatatuiRuby, you just change the Ruby object. You get Rust's performance where it matters—rendering—and Ruby's flexibility where it counts—designing.

### **Vs. Writing Raw Go**

Go is a fantastic language for CLIs, but it isn't Ruby.  
If you write your TUI in Go, you lose Ruby’s ecosystem. You lose Active Record. You lose RSpec. You lose the expressive syntax that makes Ruby a joy. RatatuiRuby lets you keep your stack. You can visualize your Rails database or monitor your Sidekiq jobs without leaving the language they are written in.

### ---

**Document Set B: For the Full Launch (Gem 1.25 / 1.5 / 2\)**

*(Context: The "Big Tent" Ecosystem exists. Focus on Choice and Architecture.)*

#### **Short Version (README.md)**

**Why RatatuiRuby?**  
RatatuiRuby is the **Universal TUI Runtime**. We believe you shouldn't have to switch rendering engines just to change your coding style.  
**Architecture Agnostic**

* **Love Functional Programming?** Use ratatui-tea. You get the clean, functional Model-View-Update loop (The Elm Architecture) you love, powered by our high-performance Rust engine.  
* **Love Objects & Components?** Use ratatui-widgets (and glimmer-dsl-ratatui). Build complex apps with stateful buttons, inputs, and declarative views.

One engine. Any architecture.  
Vs. CharmRuby  
CharmRuby creates a great TEA experience by porting Go libraries. ratatui-tea creates the same experience natively. By using RatatuiRuby, you avoid the overhead of the Go runtime and gain the rendering performance of Rust. Plus, if you ever outgrow TEA and need a complex Component system, you don't have to rewrite your renderer—you just switch gems.

#### **Long Version (Wiki)**

# **Why RatatuiRuby?**

The terminal is experiencing a renaissance. Modern terminals support millions of colors, mouse events, and complex layouts. Ruby developers should be at the forefront of this movement.  
We built the RatatuiRuby ecosystem to provide a native, "Ruby-first" path to building complex terminal applications, regardless of your preferred coding style.

## **Comparing Architectures**

### **Vs. CharmRuby**

CharmRuby brings the "Elm Architecture" (TEA) to Ruby. In this model, your application is a state machine: Message \-\> Model \-\> View. This model is robust, but it enforces a specific way of thinking.  
**RatatuiRuby offers The Big Tent:**  
1\. If you like TEA (The Functional Path)  
Our ratatui-tea gem offers the exact same Model-View-Update cycle. But it runs on our Rust engine. It is lighter (no Go runtime) and faster. It is "Just Ruby"—commands are Procs, models are Data objects.  
2\. If you like Components (The Object Path)  
Our ratatui-widgets gem offers a stateful Component system. A Button is an object that knows if it is hovered. You don't have to track global cursor state manually.  
Combined with our Glimmer DSL, you can write declarative UI code:  
vertical\_layout { button { on\_selected { ... } } }  
You get the choice. CharmRuby forces you into TEA. RatatuiRuby lets you choose the right tool for the job.

### **Vs. Writing Raw Rust**

Ratatui (Rust) is an immediate-mode renderer. It draws a frame and forgets it. It has no concept of "clicking a button" because it has no buttons—only rectangles.  
If you use raw Ratatui, you have to build your own event loop. You have to calculate which rectangle the mouse clicked. You have to track which widget is active.  
We did that work for you. RatatuiRuby includes complete runtimes. Whether you choose tea or widgets, we handle the hit-testing, the event loop, and the rendering cycle. You focus on your application logic.

### **Vs. Writing Raw Go**

The Go ecosystem (Bubble Tea) is rich but imperative. Building complex, nested layouts in Go often involves verbose struct initialization.  
Ruby excels at Domain Specific Languages (DSLs). We leverage this strength. Our Glimmer DSL allows you to visualize the hierarchy of your UI just by looking at the code. The indentation of the code matches the nesting of the widgets. This readability makes maintenance easier and development faster.  
We didn't just port a library. We built a framework designed for Rubyists.

### ---

**System Context: ECOSYSTEM.md**

*(Save this file to pass to the next agent. It is the "Constitution" of your project.)*

Markdown

\# The Ratatui Ruby Ecosystem: Architecture & Roadmap

\#\# 1\. High-Level Architecture

The ecosystem is divided into layers, moving from low-level performance (Rust) to high-level abstraction.

| Layer | Gem Name | Role | Responsibility | State |  
| :--- | :--- | :--- | :--- | :--- |  
| \*\*1. The Engine\*\* | \`ratatui\_ruby\` | \*\*Renderer\*\* | Rust FFI, Drawing, Event Polling, Layout Calculation. | \*\*Stateless\*\* (Immediate Mode) |  
| \*\*2A. The Functional Path\*\* | \`ratatui-tea\` | \*\*Runtime\*\* | The Elm Architecture (Model-View-Update). | \*\*Global Immutable State\*\* |  
| \*\*2B. The Object Path\*\* | \`ratatui-widgets\` | \*\*Components\*\* | Stateful Components, Focus Management, Hit Testing. | \*\*Distributed Object State\*\* |  
| \*\*3. The Syntax\*\* | \`glimmer-dsl-ratatui\` | \*\*DSL\*\* | Declarative View Syntax (wraps Layer 2B). | \*\*Declarative\*\* |  
| \*\*4. The Frame\*\* | \`tuis\_on\_trails\` | \*\*Framework\*\* | App Generators, MVC Pattern, DB Integration. | \*\*Opinionated\*\* |

\---

\#\# 2\. Layer 1: The Engine (\`ratatui\_ruby\`)  
\*\*Current Status:\*\* v0.3.0 (Near Feature Complete)

This is the "Metal." It wraps the Rust \`ratatui\` library via Magnus. It does \*\*not\*\* know what a "Button" or "Focus" is. It only knows \`Rect\`, \`Style\`, \`Paragraph\`, and \`Key(Char('a'))\`.

\#\#\# Responsibilities  
\* \*\*Rendering:\*\* Takes a tree of value objects (Schemas) and renders them to the buffer.  
\* \*\*Layout:\*\* Exposes the Cassowary constraint solver (Flexbox-like).  
\* \*\*Events:\*\* Polls the terminal for raw inputs (Keys, Mouse, Resize).

\#\#\# Immediate Roadmap (Phase A)  
To support Layers 2A and 2B, the Engine must expose:  
1\.  \*\*Text Measurement:\*\* \`RatatuiRuby::Text.width(string)\` for auto-sizing.  
2\.  \*\*Cursor Control:\*\* \`frame.set\_cursor(x, y)\` for Input widgets.  
3\.  \*\*Event Modifiers:\*\* \`poll\_event\` returns modifiers (Shift, Ctrl).  
4\.  \*\*Resize Events:\*\* \`poll\_event\` returns Resize dimensions.  
5\.  \*\*Timeout:\*\* \`poll\_event(timeout: Float)\` for the TEA loop.

\---

\#\# 3\. Layer 2A: The Functional Path (\`ratatui-tea\`)  
\*\*Codename:\*\* Jujube Redux  
\*\*Target:\*\* CLI tools, prototypes.

A lightweight implementation of The Elm Architecture.  
\* \*\*Philosophy:\*\* "Just Ruby." No complex base classes.  
\* \*\*API:\*\* \`TEA.run(model:, update:, view:)\`.  
\* \*\*Commands:\*\* Procs that perform work and return Messages.  
\* \*\*Concurrency:\*\* Main Thread handles UI/Logic. Worker Thread Pool handles Commands.

\---

\#\# 4\. Layer 2B: The Object Path (\`ratatui-widgets\`)  
\*\*Target:\*\* Complex Desktop-like Apps.

A Component-based system inspired by React/Flutter.  
\* \*\*Component:\*\* Base class with \`view\`, \`handle\_event\`, \`accepts\_focus?\`.  
\* \*\*Focus Manager:\*\* Handles Tab cycling and event routing.  
\* \*\*Hit Testing:\*\* Uses Layout Reflection to route mouse events to components.  
\* \*\*Reconciliation:\*\* Components generate ephemeral Layer 1 structs every frame.

\---

\#\# 5\. Layer 3: The Syntax (\`glimmer-dsl-ratatui\`)  
\*\*Target:\*\* Developers who prefer declarative code.

Wraps Layer 2B components in the Glimmer DSL.  
\* \*\*Syntax:\*\* \`vertical\_layout { button { ... } }\`.  
\* \*\*Data Binding:\*\* \`value \<= \[model, :attr\]\`.

\---

\#\# Execution Plan

1\.  \*\*Phase A (Now):\*\* Finish \`ratatui\_ruby\`. Implement the "Missing 5" primitives.  
2\.  \*\*Phase B (Quick Win):\*\* Release \`ratatui-tea\` (Gem 1.25). Captures the functional market.  
3\.  \*\*Phase C (The Main Event):\*\* Build \`ratatui-widgets\` and \`glimmer-dsl-ratatui\`.  
