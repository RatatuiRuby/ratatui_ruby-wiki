<!--
  SPDX-FileCopyrightText: 2025 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

# **Proposal Codename “Elderberry”**

This is a smart direction. Using the ratatui\_ruby- prefix is the standard RubyGems convention for extensions to a core gem (e.g., rspec-core, rspec-expectations). It implies the namespace RatatuiRuby::TEA, RatatuiRuby::Components, etc., which keeps your namespace clean and logical.  
Here is the updated architectural suite.

# ---

**1\. The RatatuiRuby Ecosystem: Architecture v2.0**

*(Replaces previous versions. Adds the TEA path.)*

## **The "Big Tent" Architecture**

The ecosystem is built on a "Forked Path" philosophy. All paths start at the **Engine**, but developers choose their paradigm (Object-Oriented vs. Functional) for the **Application Layer**.

| Gem Name | Namespace | Role | Paradigm | State |
| :---- | :---- | :---- | :---- | :---- |
| **1\. The Engine** | ratatui\_ruby | **Renderer** | **Imperative** | Stateless / Immediate Mode |
| **1.25. The Loop** | ratatui\_ruby-tea | **App Arch** | **Functional** (TEA) | Immutable State Machine |
| **1.5. The Kit** | ratatui\_ruby-components | **Component System** | **OO / Stateful** | Mutable Component Tree |
| **2.0. The Syntax** | ratatui\_ruby-glimmer | **DSL** | **Declarative** | Wrapper for Gem 1.5 |
| **3.0. The Frame** | ratatui\_ruby-trails | **Framework** | **Opinionated** | Rails-like MVC |

## ---

**2\. Integration: How Gem 1.25 Fits (and Doesn't)**

### **The "TEA Path" (Gem 1.25)**

* **Dependencies:** directly depends on ratatui\_ruby (Gem 1).  
* **Relationship to Gem 1.5:** **Mutually Exclusive.** You generally do not mix RatatuiRuby::TEA with RatatuiRuby::Components. One manages state via a single immutable struct; the other via a tree of mutable objects. Mixing them defeats the purpose of both.  
* **Relationship to Gem 2:** **Incompatible.** The Glimmer DSL is designed to build the mutable component tree of Gem 1.5. TEA views are pure functions returning Gem 1 structs directly.  
* **Target Audience:** Developers who prefer the "Elm/Redux" pattern, pure functions, and explicit state management.

### **The "Component Path" (Gem 1.5 \+ 2.0)**

* **Dependencies:** directly depends on ratatui\_ruby (Gem 1).  
* **Relationship to Gem 1.25:** **Alternative.** This path is for developers who prefer "Rails/Qt" style development, encapsulation, and declarative syntax.

# ---

**3\. Design Document: Gem 1.25 (ratatui\_ruby-tea)**

**Goal:** Provide a robust, "batteries-included" implementation of The Elm Architecture (TEA) for Ruby, leveraging the ratatui\_ruby engine.

### **Core Concepts**

The application lifecycle is defined by three pure components:

1. **Model:** An immutable data structure representing the entire application state.  
2. **View:** A pure function (Model) \-\> RatatuiRuby::Widget.  
3. **Update:** A pure function (Msg, Model) \-\> (Model, Cmd).

### **Modules & Classes**

#### **A. RatatuiRuby::TEA::Program**

The main entry point. It manages the run loop, threading for commands, and render cycles.

* **initialize(model:, update:, view:, subscriptions: nil)**  
* **run**: Starts the loop.  
  1. **Render:** Calls view.call(model) \-\> gets Gem 1 Layout/Widget tree \-\> passes to RatatuiRuby.draw.  
  2. **Poll:** Checks for generic RatatuiRuby events (Key, Mouse, Resize).  
  3. **Check Cmds:** Checks the Cmd queue for completed background tasks (results from Threads).  
  4. **Update:** If an event or command result exists, call model, cmd \= update.call(msg, model).  
  5. **Execute:** If cmd is not nil, spawn a thread/fiber to execute it.

#### **B. RatatuiRuby::TEA::Cmd**

A value object representing a "side effect" the application wants to perform (HTTP request, database query, timer).

* **Structure:** Wraps a Proc that performs work and returns a Msg.  
* **API:**  
  * Cmd.none: Do nothing.  
  * Cmd.call { ... return msg }: Create a command.  
  * Cmd.batch(\[cmd1, cmd2\]): Run multiple commands.

#### **C. RatatuiRuby::TEA::Msg**

While Ruby is dynamically typed, we encourage using Data or Symbol for messages to ensure pattern matching works cleanly in the update loop.

#### **D. RatatuiRuby::TEA::Sub (Subscriptions)**

Allows the app to listen to external event sources (timers, sockets) that push data *into* the loop, rather than being pulled.

### ---

**The Runtime Loop (Pseudocode)**

Ruby

def run  
  RatatuiRuby.run do  
    cmd\_queue \= Queue.new \# Thread-safe queue for async results

    loop do  
      \# 1\. DRAW  
      tree \= @view.call(@model)  
      RatatuiRuby.draw(tree)

      \# 2\. WAIT FOR INPUT (Non-Blocking / Timeout)  
      \# We need to wake up frequently to check the cmd\_queue  
      \# logic: wait for max 0.05s for user input.  
      event \= RatatuiRuby.poll\_event(timeout: 0.05)  
        
      msgs \= \[\]  
        
      \# 3\. PROCESS USER INPUT  
      if event  
        msgs \<\< convert\_event\_to\_msg(event)  
      end

      \# 4\. PROCESS ASYNC RESULTS  
      until cmd\_queue.empty?  
        msgs \<\< cmd\_queue.pop(true)   
      end

      \# 5\. UPDATE LOOP  
      msgs.each do |msg|  
        @model, new\_cmd \= @update.call(msg, @model)  
        execute(new\_cmd, cmd\_queue) if new\_cmd  
      end  
        
      \# Optimization: If no msgs, loop again immediately (or sleep slightly to save CPU)  
    end  
  end  
end

# ---

**4\. Critical Changes to Gem 1 (ratatui\_ruby)**

To support Gem 1.25, the Engine (Gem 1\) must support **Non-Blocking Execution**.  
Currently, RatatuiRuby.poll\_event is likely blocking (it waits indefinitely for a keypress). This kills TEA. If the user fires a Cmd that takes 5 seconds (HTTP request), and the user *doesn't* touch the keyboard, the loop hangs at poll\_event and never updates the screen with the HTTP result.

### **Requirement 1: poll\_event Timeout**

We must expose the backend's poll timeout functionality.

* **Rust Change (src/events.rs):** Update the poll\_event function to accept an optional timeout (float/seconds).  
* **Logic:** Use crossterm::event::poll(Duration::from\_secs\_f64(timeout)) before calling read().  
* **Ruby API:** RatatuiRuby.poll\_event(timeout: 0.1) returns nil if no event occurred within 100ms.

### **Requirement 2: Thread Safety (Validation)**

Since Gem 1.25 will rely heavily on Ruby Threads to run Cmds in the background, we must ensure Gem 1 is thread-safe.

* **Context:** RatatuiRuby functions (drawing, polling) will only be called from the **Main Thread** (the UI loop).  
* **Safety:** The Cmd threads will likely *only* perform pure Ruby I/O (Net::HTTP, etc.) and then push a value to a Queue. They should **not** call RatatuiRuby functions directly.  
* **Action:** No Rust changes needed *if* we document strictly that RatatuiRuby is not re-entrant. The Program class in Gem 1.25 handles this isolation naturally.

### **Requirement 3: resize Event Reliability**

In TEA, a resize is just another Msg (e.g., Msg::WindowResized(w, h)). Gem 1 must reliably report this so the View can re-calculate responsive layouts (like Constraint::Percentage).

* **Check:** Ensure the event poller maps crossterm::event::Event::Resize correctly to a Ruby hash { type: :resize, width: w, height: h }.

### ---

**Summary of Tasks**

1. **Gem 1 (Now):** Implement poll\_event(timeout:). (This is the blocker for TEA).  
2. **Gem 1 (Now):** Finish the "Missing 4" primitives (Text Width, Cursor, Modifiers, Resize).  
3. **Gem 1.25 (Next):** Implement the Program class and the Queue-based run loop.