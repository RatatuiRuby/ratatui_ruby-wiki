<!--
  SPDX-FileCopyrightText: 2026 Kerrick Long <me@kerricklong.com>
  SPDX-License-Identifier: CC-BY-SA-4.0
-->

> [!NOTE]
> This is an archived brainstorming document generated with an LLM. Personas and organizations mentioned are fictional. See [index.md](index.md) for context.

CONFIDENTIAL STRATEGIC RECORD  
Subject: RatatuiRuby Ecosystem Strategy, Architecture, and Roadmap (v2.0)  
Date: December 30, 2025  
Status: Approved for Execution

## ---

**1\. Executive Summary: "The Big Tent" Architecture**

The RatatuiRuby ecosystem will transition from a linear stack to a **Platform Architecture** offering two distinct, mutually exclusive development paths built upon a shared engine. This strategy resolves the "Expression Problem" by offering optimized tools for different domain logic.

### **The Forked Path**

All applications begin with **Layer 1 (The Engine)**. Developers then choose a paradigm:

* **Path A: The Functional Runtime (High Control)**  
  * **Gem:** ratatui\_ruby-tea (Gem 1.25)  
  * **Paradigm:** The Elm Architecture (TEA).  
  * **Focus:** State machines, data pipelines, strict flow control, CLI tools.  
  * **Mechanism:** Immutable Model $\\rightarrow$ Pure Update Function $\\rightarrow$ View Function.  
* **Path B: The Component Kit (High Velocity)**  
  * **Gem:** ratatui\_ruby-components (Gem 1.5) \+ glimmer-dsl-ratatui (Gem 2).  
  * **Paradigm:** Object-Oriented / Retained Mode.  
  * **Focus:** Dashboards, complex UI trees, enterprise platforms, "Rails-like" development.  
  * **Mechanism:** Encapsulated Objects, Event Routing, Lifecycle Methods.

## ---

**2\. Naming Conventions & Namespace Standards**

To ensure ecosystem compatibility and brand clarity, the following naming standards are strictly enforced.

| Layer | Gem Name | Namespace | Require Path | Rationale |
| :---- | :---- | :---- | :---- | :---- |
| **Engine** | ratatui\_ruby | RatatuiRuby | ratatui\_ruby | The core brand. |
| **TEA** | ratatui\_ruby-tea | RatatuiRuby::TEA | ratatui\_ruby/tea | Extension convention. |
| **Kit** | ratatui\_ruby-components | RatatuiRuby::Components | ratatui\_ruby/components | Extension convention. |
| **DSL** | glimmer-dsl-ratatui | Glimmer::DSL::Ratatui | glimmer-dsl-ratatui | **Critical:** Must follow Glimmer ecosystem auto-discovery naming (glimmer-dsl-\*). |
| **Frame** | ratatui\_ruby-trails | RatatuiRuby::Trails | ratatui\_ruby/trails | The "Rails" for TUI. |

## ---

**3\. Gem 1 (The Engine) Architecture Updates**

**Current Critical Blocker:** The current implementation of poll\_event blocks the main thread indefinitely, preventing background execution required for TEA (timers, HTTP).

### **Required Changes (P0 Priority)**

1. **Non-Blocking Polling:** Modify the Rust extension (src/events.rs) to expose crossterm::event::poll with a timeout parameter.  
   * **API:** RatatuiRuby.poll\_event(timeout: Float)  
   * **Logic:** If timeout is provided, poll for that duration. If event exists, read and return. If not, return nil.  
2. **Resize Events:** Ensure crossterm::event::Event::Resize is correctly mapped to a Ruby hash { type: :resize, width: w, height: h } to trigger view recalculations.  
3. **Thread Safety:** Maintain strict documentation that RatatuiRuby drawing functions are **Main Thread Only**.

## ---

**4\. Gem 1.25 (TEA) Design & Runtime**

**Philosophy:** "Data in, Data out."

### **The Runtime Strategy: "The Trojan Horse"**

To support Ruby 4.0's Ractor concurrency model without waiting for ecosystem maturity:

1. **v1.x Implementation:** The runtime will use standard Thread and Queue classes for stability.  
2. **Ractor Enforcement:** The API will **enforce Ractor-safety rules immediately**.  
   * In development/debug mode, the runtime will attempt to call Ractor.make\_shareable on Models and Messages.  
   * If a user passes a mutable object (like a raw Proc closing over state), the app will raise an error.  
3. **v2.0 Path:** When the runtime engine swaps Threads for Ractors in v2.0, user code will upgrade seamlessly without rewrites because data hygiene was enforced from Day 1\.

### **API Design**

* **No Base Classes:** Users will **not** inherit from class App \< TEA::App.  
* **Callable Objects:** The Program initializer will accept **any object responding to \#call** (Procs, Lambdas, or Service Objects) for update and view.  
  * *Benefit:* Allows dependency injection and avoids "inheritance magic."  
* **Fractal Architecture:** To prevent the "God Reducer" problem (monolithic case statements), documentation must prominently feature "Fractal" composition patterns (delegating updates to sub-models) in the *Getting Started* guide.

## ---

**5\. Product Strategy: Batteries & Dependencies**

**Strategy:** "Strict Core, Loose Peripherals."

### **A. The Core (Batteries Included)**

We must ship a standard library of Cmd generators using **Zero External Dependencies** (Ruby Stdlib only).

* Cmd.wait(seconds)  
* Cmd.tick(interval) (for spinners)  
* Cmd.exec(shell\_command)

### **B. The Peripherals (Plug-and-Play)**

We will **not** ship a specific HTTP client dependency in the core gem to avoid bloat and conflicts.

* **The Interface:** A generic Cmd.call wrapper will be provided.  
* **Implementation 1 (Built-in):** RatatuiRuby::TEA::Cmd::NetHttp. A basic wrapper around Net::HTTP for simple use cases.  
* **Implementation 2 (Reference):** ratatui\_ruby-tea-httpx. A separate example gem/repository demonstrating how to wrap a robust client (httpx or faraday) into the Cmd interface.

## ---

**6\. Gem 2 (Glimmer) Scope & Integration**

**Decision:** Glimmer DSL support is **CUT** from the initial TEA v1.0 release.

* **Rationale:** TEA relies on immutable state; Glimmer relies on bi-directional data binding. Combining them strips Glimmer of its primary value, reducing it to syntax sugar.  
* **Future State:** glimmer-dsl-ratatui will eventually support TEA view generation (as a uni-directional HTML-style builder) but will explicitly document that data binding is forbidden in that context.

## ---

**7\. Positioning & Messaging**

We will market the ecosystem using **4 Angles** to address distinct user personas without denigrating either architectural path.

| Persona | The Pitch |
| :---- | :---- |
| **Junior Dev** | **"Checklist vs. LEGOs."** Use TEA for a strict safety checklist. Use Components for snapping together pre-made blocks. |
| **Frontend Dev** | **"Redux vs. React."** TEA is Redux (pure state). Components are React Class Components (lifecycle & local state). |
| **Polyglot** | **"Expression Problem Solved."** Use TEA for Event-Driven tools (CLI). Use Components for Object-Oriented platforms (Dashboards). |
| **Omakase Rubyist** | **"The Standard Architecture."** TEA is not "Functional Programming"; it is **Convention over Configuration** for the event loop. The Model is your Database in RAM; the Update is your Controller. |

## ---

**8\. Execution Roadmap (Order of Operations)**

The rollout follows an "Onion Peel" strategy to deliver valid software at every stage, avoiding a "Big Bang" release.

1. **Immediate Blocker (P0):**  
   * Implement poll\_event(timeout:) in Rust (ratatui\_ruby).  
   * Verify Resize event mapping.  
2. **Phase A: The TEA Runtime:**  
   * Build ratatui\_ruby-tea (Gem 1.25) using the Thread/Queue runtime.  
   * Implement Ractor-safety enforcement checks.  
   * Ship with "Standard Lib" commands (Net::HTTP wrapper, Tickers).  
   * *Deliverable:* Working TEA runtime with standard Ruby syntax (no DSL).  
3. **Phase B: The Component Kit (Beta):**  
   * Ship ratatui\_ruby-components (Gem 1.5).  
   * Support **Custom Components** only (User defines class MyButton).  
   * No built-in widget library yet.  
4. **Phase C: The Syntax (Beta):**  
   * Ship glimmer-dsl-ratatui (Gem 2).  
   * Support uni-directional view generation for TEA.  
   * Support uni-directional binding for Custom Components.  
5. **Phase D: Iterative Maturity:**  
   * Update Glimmer to support **Bi-Directional Binding** for Components.  
   * Iteratively release **Built-in Wrappers** (wrapping Ratatui widgets one by one into the Component system).  
   * Eventually introduce ratatui\_ruby-bubbles (a library of high-level components inspired by Charm).

---

Signed & Verified,  
The Technical Writer